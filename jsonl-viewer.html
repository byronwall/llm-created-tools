<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>JSONL Log Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: light dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      background: #0f172a;
      color: #e5e7eb;
    }

    header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #1f2937;
      background: linear-gradient(90deg, #020617, #111827);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    header h1 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #9ca3af;
    }

    #drop-zone {
      border: 1px dashed #4b5563;
      border-radius: 0.75rem;
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      transition: border-color 0.15s ease, background-color 0.15s ease;
      background: #030712;
    }

    #drop-zone.dragover {
      border-color: #38bdf8;
      background: #020617;
    }

    #drop-zone span {
      color: #9ca3af;
    }

    #file-input {
      display: none;
    }

    main {
      display: flex;
      flex: 1;
      min-height: 0; /* allow children to manage their own scroll */
    }

    .resizer {
      width: 6px;
      cursor: col-resize;
      background: transparent;
      position: relative;
    }
    .resizer::before {
      content: '';
      position: absolute;
      left: 2px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #1f2937;
      opacity: 0.7;
    }
    .resizer:hover::before,
    .resizer.dragging::before {
      background: #38bdf8;
      opacity: 0.9;
    }

    #sidebar {
      width: 250px;
      max-width: 40%;
      border-right: 1px solid #1f2937;
      display: flex;
      flex-direction: column;
      min-height: 0; /* prevent sidebar from forcing page scroll */
      overflow: hidden; /* confine scroll to internal list */
      background: #020617;
    }

    #log-filter {
      width: 100%;
      margin: 0.5rem 0.75rem;
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid #111827;
      background: #0b1020;
      color: #e5e7eb;
      font-size: 0.8rem;
    }

    #log-filter::placeholder {
      color: #6b7280;
    }

    #log-summary-header {
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    #log-count {
      font-weight: 600;
      color: #e5e7eb;
    }

    #log-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto; /* scroll inside sidebar */
      flex: 1;
      min-height: 0;
    }

    .log-item {
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #111827;
      cursor: pointer;
      font-size: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      background: transparent;
      transition: background 0.1s ease;
    }

    .log-item:hover {
      background: #020617;
    }

    .log-item.selected {
      background: #0f172a;
      border-left: 3px solid #38bdf8;
      padding-left: 0.6rem;
    }

    .log-item-title {
      font-weight: 500;
      color: #e5e7eb;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .log-item-meta {
      font-size: 0.7rem;
      color: #9ca3af;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }

    #detail {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
      background: radial-gradient(circle at top left, #111827, #020617 60%);
    }

    #detail-header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }

    #detail-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #e5e7eb;
    }

    #detail-meta {
      font-size: 0.75rem;
      color: #9ca3af;
    }

    #detail-content {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 0.75rem;
      padding: 0.75rem;
      min-height: 0;
    }

    @media (max-width: 800px) {
      main {
        flex-direction: column;
      }

      #sidebar {
        width: 100%;
        max-width: 100%;
        max-height: 40vh;
      }

      #detail-content {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .panel {
      border-radius: 0.75rem;
      border: 1px solid #111827;
      background: #020617;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .panel-header {
      padding: 0.4rem 0.6rem;
      border-bottom: 1px solid #111827;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .panel-body {
      padding: 0.4rem 0.6rem;
      overflow: auto;
      font-size: 0.8rem;
    }

    pre {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem;
      background: #020617;
      padding: 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid #111827;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .multiline {
      background: #020617;
      padding: 0.25rem 0.4rem;
      border-radius: 0.4rem;
      border: 1px solid #111827;
      margin: 0.2rem 0;
    }

    table.kv-table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.8rem;
    }

    table.kv-table tr > td {
      border-bottom: 1px solid #111827;
      vertical-align: top;
      padding: 0.25rem 0.35rem;
    }

    table.kv-table tr:last-child > td {
      border-bottom: none;
    }

    /* Subtle striping for readability */
    table.kv-table tr:nth-child(odd) {
      background-color: rgba(2, 6, 23, 0.35); /* very subtle in dark */
    }
    table.kv-table tr:nth-child(even) {
      background-color: rgba(17, 24, 39, 0.35);
    }

    /* Increase contrast slightly for nested tables to show grouping */
    td.value table.kv-table tr:nth-child(odd) {
      background-color: rgba(30, 58, 138, 0.25);
    }
    td.value table.kv-table tr:nth-child(even) {
      background-color: rgba(2, 132, 199, 0.18);
    }

    /* Keep cell backgrounds transparent so striping shows across row */
    table.kv-table td.key,
    table.kv-table td.value {
      background: transparent;
    }

    table.kv-table td.key {
      width: 30%;
      max-width: 30%;
      font-weight: 500;
      color: #f9fafb;
      white-space: nowrap;
    }

    table.kv-table td.value {
      width: 70%;
      max-width: 70%;
    }

    .badge {
      border-radius: 9999px;
      border: 1px solid #1f2937;
      padding: 0.15rem 0.5rem;
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .badge-idx {
      border-color: #38bdf8;
      color: #38bdf8;
    }

    .hint {
      font-size: 0.75rem;
      color: #6b7280;
    }

    .error {
      color: #fca5a5;
      font-size: 0.8rem;
      margin-top: 0.25rem;
    }

    .faded {
      color: #4b5563;
    }

    /* Log level palette + chip styles */
    .legend { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; }
    .legend-item { display:flex; align-items:center; gap:0.35rem; font-size:0.72rem; color:#9ca3af; }
    .chip { display:inline-flex; align-items:center; justify-content:center; min-width: 2.1rem; height: 1.15rem; padding: 0 0.4rem; border-radius: 9999px; font-size: 0.68rem; font-weight: 600; letter-spacing: 0.02em; border: 1px solid transparent; }
    .chip.debug { color:#8ab4f8; background: rgba(30,64,175,0.18); border-color: rgba(30,64,175,0.35); }
    .chip.info { color:#7dd3fc; background: rgba(2,132,199,0.18); border-color: rgba(2,132,199,0.35); }
    .chip.notice { color:#a7f3d0; background: rgba(16,185,129,0.18); border-color: rgba(16,185,129,0.35); }
    .chip.warn { color:#fcd34d; background: rgba(234,179,8,0.18); border-color: rgba(234,179,8,0.35); }
    .chip.error { color:#fca5a5; background: rgba(239,68,68,0.18); border-color: rgba(239,68,68,0.35); }
    .chip.critical { color:#fda4af; background: rgba(244,63,94,0.20); border-color: rgba(244,63,94,0.40); }
    .chip.fatal { color:#fecaca; background: rgba(220,38,38,0.22); border-color: rgba(220,38,38,0.45); }
    .chip.trace { color:#c4b5fd; background: rgba(99,102,241,0.18); border-color: rgba(99,102,241,0.35); }
    .chip.silent { color:#9ca3af; background: rgba(75,85,99,0.15); border-color: rgba(75,85,99,0.3); }
    .log-item { flex-direction: row; align-items: center; gap: 0.5rem; }
    .log-item-title { flex: 1; }
  </style>
</head>
<body>
  <header>
    <h1>JSONL Log Viewer</h1>
    <div style="display:flex; gap:0.5rem; align-items:center;">
      <div id="drop-zone">
        <span>Drop a .jsonl file here or click to select</span>
        <input type="file" id="file-input" accept=".jsonl,.log,.txt,application/jsonl" />
      </div>
      <button id="folder-button" type="button" class="badge">Load folder…</button>
      <input type="file" id="folder-input" webkitdirectory multiple style="display:none" accept=".jsonl,.log,.txt,application/jsonl" />
    </div>
    <div class="legend" title="Log level legend">
      <div class="legend-item"><span class="chip trace">TRACE</span><span>Very verbose</span></div>
      <div class="legend-item"><span class="chip debug">DEBUG</span><span>Debugging info</span></div>
      <div class="legend-item"><span class="chip info">INFO</span><span>General info</span></div>
      <div class="legend-item"><span class="chip notice">NOTICE</span><span>Notable events</span></div>
      <div class="legend-item"><span class="chip warn">WARN</span><span>Potential issues</span></div>
      <div class="legend-item"><span class="chip error">ERROR</span><span>Errors</span></div>
      <div class="legend-item"><span class="chip critical">CRIT</span><span>Critical</span></div>
      <div class="legend-item"><span class="chip fatal">FATAL</span><span>Unrecoverable</span></div>
    </div>
  </header>

  <main>
    <section id="file-sidebar" style="width:260px; max-width:60%; border-right:1px solid #1f2937; display:flex; flex-direction:column; min-height:0; overflow:hidden; background:#020617;">
      <div class="panel-header" style="border-bottom:1px solid #1f2937;">
        <span>Files</span>
        <span id="file-total" class="badge">0 files</span>
      </div>
      <div style="padding:0.4rem 0.6rem; display:flex; gap:0.4rem; align-items:center;">
        <input id="file-filter" type="text" placeholder="Filter folders / files…" aria-label="Filter files" style="flex:1; padding:0.35rem 0.5rem; border-radius:0.5rem; border:1px solid #111827; background:#0b1020; color:#e5e7eb; font-size:0.8rem;" />
      </div>
      <div id="file-tree-container" style="flex:1; min-height:0; overflow:auto;">
        <ul id="file-tree-root" style="list-style:none; margin:0; padding:0;"></ul>
      </div>
    </section>
    <div class="resizer" data-target="file-sidebar" data-side="right" title="Drag to resize"></div>
    <section id="sidebar" style="flex-basis: 420px; min-width: 240px; max-width: 70%;">
      <div id="log-summary-header">
        <span>Logs</span>
        <span id="log-count" class="badge">0 entries</span>
      </div>
      <div style="padding:0 0.75rem 0.5rem; display:flex; gap:0.4rem; align-items:center; flex-wrap:wrap;">
        <input id="log-filter" type="text" placeholder="Filter by title / file…" aria-label="Filter logs"
               style="flex:1;" />
        <label class="badge" style="cursor:pointer; display:flex; align-items:center; gap:0.35rem;">
          <input id="flat-toggle" type="checkbox" />
          <span>Flat list</span>
        </label>
      </div>
      <div id="tree-container" style="display:none"></div>
      <ul id="log-list"></ul>
    </section>
    <div class="resizer" data-target="sidebar" data-side="right" title="Drag to resize"></div>

    <section id="detail">
      <div id="detail-header">
        <div>
          <div id="detail-title" class="faded">No log selected</div>
          <div id="detail-meta" class="hint">Load a JSONL file to begin.</div>
        </div>
        <button id="view-toggle" type="button" class="badge" title="Toggle RAW/STRUCTURED">Show Raw</button>
      </div>
      <div id="detail-content">
        <div class="panel">
          <div class="panel-header">
            <span id="panel-title">Structured View</span>
            <span id="panel-hint" class="hint">Nested key/value</span>
          </div>
          <div class="panel-body">
            <pre id="raw-json" style="display:none">/* Waiting for a log entry... */</pre>
            <div id="structured-view" class="hint">
              Multiline strings will appear in highlighted blocks here.
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    (function () {
      // --- Resizable sidebars setup ---
      const mainEl = document.querySelector('main');
      const fileSidebarEl = document.getElementById('file-sidebar');
      const logsSidebarEl = document.getElementById('sidebar');
      const detailEl = document.getElementById('detail');
      const resizers = Array.from(document.querySelectorAll('.resizer'));

      const LS_KEYS = {
        fileSidebarWidth: 'jsonl_viewer_file_sidebar_width',
        logsSidebarWidth: 'jsonl_viewer_logs_sidebar_width',
      };

      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }

      function applyInitialSizes() {
        const fs = Number(localStorage.getItem(LS_KEYS.fileSidebarWidth) || 260);
        const ls = Number(localStorage.getItem(LS_KEYS.logsSidebarWidth) || 420);
        fileSidebarEl.style.width = fs + 'px';
        logsSidebarEl.style.flexBasis = ls + 'px';
      }

      applyInitialSizes();

      resizers.forEach((rz) => {
        let startX = 0;
        let startWidth = 0;
        let targetEl = null;
        let key = null;

        function onMouseMove(e) {
          const dx = e.clientX - startX;
          const side = rz.dataset.side || 'right';
          let newWidth = side === 'right' ? startWidth + dx : startWidth - dx;
          const min = 220;
          const max = Math.floor(mainEl.clientWidth * 0.7);
          newWidth = clamp(newWidth, min, max);

          if (key === LS_KEYS.fileSidebarWidth) {
            targetEl.style.width = newWidth + 'px';
          } else {
            // logs sidebar: use flex-basis so it plays nicely with flex layouts
            targetEl.style.flexBasis = newWidth + 'px';
          }
        }

        function onMouseUp() {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          rz.classList.remove('dragging');
          // Persist
          let current;
          if (key === LS_KEYS.fileSidebarWidth) {
            current = parseInt(targetEl.style.width || '260', 10);
          } else {
            current = parseInt(targetEl.style.flexBasis || '420', 10);
          }
          try {
            localStorage.setItem(key, String(current));
          } catch {}
        }

        rz.addEventListener('mousedown', (e) => {
          const targetId = rz.dataset.target;
          targetEl = document.getElementById(targetId);
          if (!targetEl) return;
          key = targetId === 'file-sidebar' ? LS_KEYS.fileSidebarWidth : LS_KEYS.logsSidebarWidth;

          startX = e.clientX;
          // Infer starting width based on style
          if (key === LS_KEYS.fileSidebarWidth) {
            startWidth = parseInt(targetEl.style.width || targetEl.getBoundingClientRect().width, 10);
          } else {
            const basis = targetEl.style.flexBasis;
            startWidth = parseInt(basis || targetEl.getBoundingClientRect().width, 10);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
          rz.classList.add('dragging');
        });
      });

      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('file-input');
      const folderButton = document.getElementById('folder-button');
      const folderInput = document.getElementById('folder-input');
      const logList = document.getElementById('log-list');
      const logCount = document.getElementById('log-count');
      const logFilter = document.getElementById('log-filter');
      const flatToggle = document.getElementById('flat-toggle');
      const treeRoot = document.getElementById('file-tree-root');
      const treeContainer = document.getElementById('file-tree-container');
      const fileFilter = document.getElementById('file-filter');
      const fileTotal = document.getElementById('file-total');
      const detailTitle = document.getElementById('detail-title');
      const detailMeta = document.getElementById('detail-meta');
      const rawJsonEl = document.getElementById('raw-json');
      const structuredEl = document.getElementById('structured-view');
      const viewToggleBtn = document.getElementById('view-toggle');
      const panelTitleEl = document.getElementById('panel-title');
      const panelHintEl = document.getElementById('panel-hint');

      /** @type {any[]} */
      let logs = [];
      let filteredLogs = [];
      let filterQuery = '';
      let selectedIndex = -1;
      let fileIndex = []; // [{path, name, file}]
      let useFlatList = true; // right sidebar shows flat logs for selected file
      let currentFilePath = null; // selected file path
      let viewMode = 'structured'; // 'structured' | 'raw'

      console.log('[JSONL Viewer] Initialized');

      function formatError(msg) {
        return '<div class="error">' + msg + '</div>';
      }

      function updateLogCount() {
        logCount.textContent = logs.length + (logs.length === 1 ? ' entry' : ' entries');
        console.log('[JSONL Viewer] Log count updated:', logs.length);
      }

      function clearList() {
        logList.innerHTML = '';
        selectedIndex = -1;
        console.log('[JSONL Viewer] Log list cleared');
      }

      function createListItem(entry, index) {
        const li = document.createElement('li');
        li.className = 'log-item';
        li.dataset.index = String(index);
        // Level chip mapping
        const levelInfo = getLevelInfo(entry);
        const chip = document.createElement('span');
        chip.className = 'chip ' + levelInfo.className;
        chip.textContent = levelInfo.label;
        li.appendChild(chip);

        const title = document.createElement('div');
        title.className = 'log-item-title';

        const metaRow = document.createElement('div');
        metaRow.className = 'log-item-meta';

        const idxSpan = document.createElement('span');
        idxSpan.textContent = '#' + index;
        idxSpan.className = 'badge badge-idx';

        const previewSpan = document.createElement('span');
        previewSpan.className = 'faded';

        const previewFull = getPreview(entry);
        const previewShort = previewFull.length > 60 ? (previewFull.slice(0, 57) + '…') : previewFull;
        title.textContent = previewShort || '(empty)';

        let tsGuess = null;
        if (entry && typeof entry === 'object') {
          tsGuess = entry.timestamp || entry.time || entry.ts || null;
        }

        const tsSpan = document.createElement('span');
        tsSpan.textContent = tsGuess ? String(tsGuess) : '';
        tsSpan.className = 'faded';
        metaRow.appendChild(idxSpan);
        metaRow.appendChild(tsSpan);

        li.appendChild(title);
        li.appendChild(metaRow);

        li.addEventListener('click', () => {
          console.log('[JSONL Viewer] Log item clicked:', index);
          selectLog(index);
        });

        return li;
      }

      // Normalize level to a label + class for coloring
      function getLevelInfo(entry) {
        console.log("[JSONL Viewer] Inferring log level for entry", entry);
        let raw = null;
        if (entry && typeof entry === 'object') {
          raw = entry.level ?? entry.severity ?? entry.lvl ?? entry.priority ?? entry.log_level ?? null;
        }
        console.log("[JSONL Viewer] Raw level value:", raw);
        let label = 'INFO';
        let cls = 'info';
        if (raw != null) {
          const s = String(raw).toLowerCase();
          // Named levels
          if (/(trace)/.test(s)) { label = 'TRACE'; cls = 'trace'; }
          else if (/(debug|dbg)/.test(s)) { label = 'DEBUG'; cls = 'debug'; }
          else if (/(info|information)/.test(s)) { label = 'INFO'; cls = 'info'; }
          else if (/(notice)/.test(s)) { label = 'NOTICE'; cls = 'notice'; }
          else if (/(warn|warning)/.test(s)) { label = 'WARN'; cls = 'warn'; }
          else if (/(error|err)/.test(s)) { label = 'ERROR'; cls = 'error'; }
          else if (/(crit|critical)/.test(s)) { label = 'CRIT'; cls = 'critical'; }
          else if (/(fatal)/.test(s)) { label = 'FATAL'; cls = 'fatal'; }
          else {
            // Numeric mapping (common schemes): lower = verbose, higher = severe
            const n = Number(s);
            if (Number.isFinite(n)) {
              if (n <= 5) { label = 'TRACE'; cls = 'trace'; }
              else if (n <= 10) { label = 'DEBUG'; cls = 'debug'; }
              else if (n <= 20) { label = 'INFO'; cls = 'info'; }
              else if (n <= 25) { label = 'NOTICE'; cls = 'notice'; }
              else if (n <= 30) { label = 'WARN'; cls = 'warn'; }
              else if (n <= 40) { label = 'ERROR'; cls = 'error'; }
              else if (n <= 50) { label = 'CRIT'; cls = 'critical'; }
              else { label = 'FATAL'; cls = 'fatal'; }
            } else {
              label = String(raw).toUpperCase().slice(0, 5);
              cls = 'silent';
            }
          }
        }
        return { label, className: cls };
      }

      function renderList() {
        clearList();
        // Only show logs when a file is selected
        if (!currentFilePath) {
          const placeholder = document.createElement('li');
          placeholder.className = 'log-item';
          const title = document.createElement('div');
          title.className = 'log-item-title';
          title.textContent = 'Select a file to view logs';
          const meta = document.createElement('div');
          meta.className = 'log-item-meta';
          const hint = document.createElement('span');
          hint.className = 'hint';
          hint.textContent = 'No file selected';
          meta.appendChild(hint);
          placeholder.appendChild(title);
          placeholder.appendChild(meta);
          logList.appendChild(placeholder);
          logCount.textContent = '0 entries';
          logList.style.display = 'block';
          treeContainer.style.display = 'block';
          return;
        }

        const base = logs.filter((en) => en && en.__sourcePath === currentFilePath);
        const source = filterQuery ? filteredLogs : base;

        source.forEach((entry, index) => {
          const li = createListItem(entry, index);
          logList.appendChild(li);
        });
        logCount.textContent = (source.length) + (source.length === 1 ? ' entry' : ' entries');
        logList.style.display = 'block';
        treeContainer.style.display = 'block';
      }

      function selectLog(index) {
        // Use the same source list as renderList() to keep indices aligned
        const base = currentFilePath
          ? logs.filter((en) => en && en.__sourcePath === currentFilePath)
          : logs;
        const source = filterQuery ? filteredLogs : base;
        if (index < 0 || index >= source.length) {
          console.warn('[JSONL Viewer] Invalid index selected:', index);
          return;
        }

        selectedIndex = index;

        Array.from(logList.children).forEach((li) => {
          li.classList.toggle('selected', Number(li.dataset.index) === index);
        });

        const entry = source[index];

        detailTitle.textContent = 'Entry #' + index;
        const extraMeta = [];
        if (entry && typeof entry === 'object') {
          const ts = entry.timestamp || entry.time || entry.ts;
          if (ts) {
            extraMeta.push('timestamp: ' + ts);
          }
        }
        extraMeta.push('type: ' + (typeof entry));
        detailMeta.textContent = extraMeta.join(' • ');

        try {
          rawJsonEl.textContent = JSON.stringify(entry, null, 2);
        } catch (err) {
          console.error('[JSONL Viewer] Error stringifying JSON:', err);
          rawJsonEl.textContent = 'Error stringifying JSON: ' + err;
        }

        structuredEl.innerHTML = '';
        structuredEl.appendChild(renderValue(entry));

        applyViewMode();
      }
      function applyViewMode() {
        const isStructured = viewMode === 'structured';
        rawJsonEl.style.display = isStructured ? 'none' : '';
        structuredEl.style.display = isStructured ? '' : 'none';
        panelTitleEl.textContent = isStructured ? 'Structured View' : 'Raw JSON';
        panelHintEl.textContent = isStructured ? 'Nested key/value' : 'Pretty-printed';
        viewToggleBtn.textContent = isStructured ? 'Show Raw' : 'Show Structured';
      }

      // Initialize default view
      applyViewMode();

      // Toggle button wiring
      viewToggleBtn.addEventListener('click', () => {
        viewMode = viewMode === 'structured' ? 'raw' : 'structured';
        applyViewMode();
      });

      function getPreview(entry) {
        if (entry && typeof entry === 'object') {
          const keys = Object.keys(entry);
          if (keys.includes('title')) return String(entry.title);
          if (keys.includes('message')) return String(entry.message);
          if (keys.includes('msg')) return String(entry.msg);
          if (keys.includes('event')) return String(entry.event);
          return keys.slice(0, 3).join(', ');
        }
        return String(entry || '');
      }

      function applyFilter(query) {
        filterQuery = query.trim().toLowerCase();
        const base = currentFilePath
          ? logs.filter((en) => en && en.__sourcePath === currentFilePath)
          : logs;
        if (!filterQuery) {
          filteredLogs = base;
          renderList();
          return;
        }
        filteredLogs = base
          .map((entry, idx) => ({ entry, idx }))
          .filter(({ entry }) => getPreview(entry).toLowerCase().includes(filterQuery))
          .map(({ entry }) => entry);
        renderList();
      }

      function renderValue(value) {
        console.log('[JSONL Viewer] Rendering value of type:', typeof value);

        if (value === null || value === undefined) {
          const span = document.createElement('span');
          span.className = 'faded';
          span.textContent = String(value);
          return span;
        }

        if (typeof value === 'string') {
          if (value.includes('\n')) {
            const pre = document.createElement('pre');
            pre.className = 'multiline';
            pre.textContent = value;
            return pre;
          }

          const span = document.createElement('span');
          span.textContent = value;
          return span;
        }

        if (typeof value === 'number' || typeof value === 'boolean') {
          const span = document.createElement('span');
          span.textContent = String(value);
          return span;
        }

        if (Array.isArray(value)) {
          const wrapper = document.createElement('div');
          const info = document.createElement('div');
          info.className = 'hint';
          info.textContent = 'Array[' + value.length + ']';
          wrapper.appendChild(info);

          const table = document.createElement('table');
          table.className = 'kv-table';

          value.forEach((item, idx) => {
            const tr = document.createElement('tr');
            const tdKey = document.createElement('td');
            tdKey.className = 'key';
            tdKey.textContent = '[' + idx + ']';

            const tdVal = document.createElement('td');
            tdVal.className = 'value';
            tdVal.appendChild(renderValue(item));

            tr.appendChild(tdKey);
            tr.appendChild(tdVal);
            table.appendChild(tr);
          });

          wrapper.appendChild(table);
          return wrapper;
        }

        if (typeof value === 'object') {
          const wrapper = document.createElement('div');
          const table = document.createElement('table');
          table.className = 'kv-table';

          // Exclude special/internal fields (e.g., __sourceFile, __sourcePath)
          const keys = Object.keys(value).filter((k) => !(k.startsWith('__')));
          keys.forEach((key) => {
            const tr = document.createElement('tr');
            const tdKey = document.createElement('td');
            tdKey.className = 'key';
            tdKey.textContent = key;

            const tdVal = document.createElement('td');
            tdVal.className = 'value';
            tdVal.appendChild(renderValue(value[key]));

            tr.appendChild(tdKey);
            tr.appendChild(tdVal);
            table.appendChild(tr);
          });

          wrapper.appendChild(table);
          return wrapper;
        }

        const span = document.createElement('span');
        span.textContent = String(value);
        return span;
      }

      function parseJsonl(text) {
        console.log('[JSONL Viewer] Parsing JSONL text');
        const lines = text.split(/\r?\n/);
        const entries = [];
        const errors = [];

        lines.forEach((line, idx) => {
          const trimmed = line.trim();
          if (!trimmed) {
            return;
          }

          try {
            const parsed = JSON.parse(trimmed);
            entries.push(parsed);
          } catch (err) {
            console.error('[JSONL Viewer] Error parsing line', idx, err);
            errors.push({ line: idx + 1, error: String(err), content: trimmed });
          }
        });

        return { entries, errors };
      }

      async function loadFiles(files) {
        if (!files || !files.length) {
          console.log('[JSONL Viewer] No files passed to loadFiles');
          return;
        }

        console.log('[JSONL Viewer] Loading', files.length, 'file(s)');

        // Reset UI state so new loads don't require refresh
        logs = [];
        filteredLogs = [];
        filterQuery = '';
        logFilter.value = '';
        fileIndex = [];
        currentFilePath = null;
        logList.innerHTML = '';
        treeRoot.innerHTML = '';

        const allEntries = [];
        const allErrors = [];

        for (const file of files) {
          const rel = file.webkitRelativePath || file.name;
          fileIndex.push({ path: rel, name: file.name, file });
          const text = await file.text();
          const { entries, errors } = parseJsonl(text);
          // annotate entries with source info
          entries.forEach((e) => {
            if (e && typeof e === 'object') {
              e.__sourcePath = rel;
              e.__sourceFile = file.name;
            }
          });
          allEntries.push(...entries);
          if (errors.length) {
            allErrors.push({ file: rel, errors });
          }
        }

        logs = allEntries;
        buildTree(fileIndex);
        // Auto-select single dropped/loaded file in left view
        if (files.length === 1) {
          const onlyPath = files[0].webkitRelativePath || files[0].name;
          currentFilePath = onlyPath;
        } else {
          currentFilePath = null;
        }
        renderList();
        if (currentFilePath) {
          // Show logs for the selected file and select first entry
          filteredLogs = logs.filter((en) => en && en.__sourcePath === currentFilePath);
          if (filteredLogs.length) selectLog(0);
        }

        if (logs.length === 0) {
          detailTitle.textContent = 'No log entries found';
          detailMeta.textContent = 'The folder was read, but no JSONL lines were found.';
          rawJsonEl.textContent = '/* No entries */';
          structuredEl.innerHTML = 'No entries.';
        }

        if (allErrors.length > 0) {
          const flatErrorCount = allErrors.reduce((sum, f) => sum + f.errors.length, 0);
          const errorSummary = `Warning: ${flatErrorCount} line(s) could not be parsed across ${allErrors.length} file(s).`;
          detailMeta.textContent += ' • ' + errorSummary;
          console.warn('[JSONL Viewer] Parse errors:', allErrors);
        }
      }

      function loadFile(file) {
        if (!file) return;

        console.log('[JSONL Viewer] Loading file:', file.name, file.size, 'bytes');

        // Delegate to multi-file path for consistency
        loadFiles([file]).catch((err) => {
          console.error('[JSONL Viewer] Error reading file:', err);
          detailMeta.textContent = 'Error reading file.';
        });
      }

      dropZone.addEventListener('click', () => {
        console.log('[JSONL Viewer] Drop-zone clicked');
        fileInput.click();
      });

      fileInput.addEventListener('change', (event) => {
        const file = event.target.files && event.target.files[0];
        loadFile(file);
      });

      // Folder picker wiring
      folderButton.addEventListener('click', () => {
        console.log('[JSONL Viewer] Folder button clicked');
        folderInput.click();
      });
      folderInput.addEventListener('change', (event) => {
        const files = Array.from(event.target.files || []);
        const jsonlFiles = files.filter((f) => /\.(jsonl|log|txt)$/i.test(f.name));
        loadFiles(jsonlFiles);
      });

      dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        dropZone.classList.add('dragover');
      });

      dropZone.addEventListener('dragleave', (event) => {
        event.preventDefault();
        dropZone.classList.remove('dragover');
      });

      dropZone.addEventListener('drop', (event) => {
        event.preventDefault();
        dropZone.classList.remove('dragover');
        const files = Array.from(event.dataTransfer.files || []);
        // If a folder is dropped (webkitRelativePath available), treat as multi-file
        if (files.length > 1 || (files[0] && files[0].webkitRelativePath)) {
          const jsonlFiles = files.filter((f) => /\.(jsonl|log|txt)$/i.test(f.name));
          loadFiles(jsonlFiles);
        } else {
          const file = files[0];
          loadFile(file);
        }
      });

      // Page-wide drag & drop
      document.addEventListener('dragover', (event) => {
        event.preventDefault();
      });
      document.addEventListener('drop', (event) => {
        event.preventDefault();
        const files = Array.from((event.dataTransfer && event.dataTransfer.files) || []);
        if (!files.length) return;
        if (files.length > 1 || (files[0] && files[0].webkitRelativePath)) {
          const jsonlFiles = files.filter((f) => /\.(jsonl|log|txt)$/i.test(f.name));
          loadFiles(jsonlFiles);
        } else {
          loadFile(files[0]);
        }
      });

      // Filter input with simple debounce
      let filterTimer = null;
      logFilter.addEventListener('input', (e) => {
        const val = e.target.value;
        if (filterTimer) clearTimeout(filterTimer);
        filterTimer = setTimeout(() => applyFilter(val), 120);
      });

      // Flat list toggle now always true; keep checkbox for UX but disable toggling
      flatToggle.addEventListener('change', (e) => {
        e.target.checked = true;
      });

      // Tree building and interactions
      function buildTree(files) {
        // files: [{path, name, file}]
        treeRoot.innerHTML = '';
        // Build nested object structure
        const root = {};
        files.forEach(({ path, name }) => {
          const parts = path.split('/');
          let node = root;
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            const isFile = i === parts.length - 1;
            if (!node[part]) node[part] = isFile ? { __file: true, name } : {};
            node = node[part];
          }
        });

        // Precompute counts per file
        const counts = {};
        logs.forEach((en) => {
          const p = en && en.__sourcePath;
          if (p) counts[p] = (counts[p] || 0) + 1;
        });
        fileTotal.textContent = Object.keys(counts).length + (Object.keys(counts).length === 1 ? ' file' : ' files');

        function createFolderLi(label) {
          const li = document.createElement('li');
          li.style.padding = '0.25rem 0.5rem';
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.gap = '0.4rem';
          const toggle = document.createElement('span');
          toggle.textContent = '▸';
          toggle.style.cursor = 'pointer';
          toggle.style.color = '#9ca3af';
          const nameEl = document.createElement('span');
          nameEl.textContent = label;
          nameEl.style.color = '#e5e7eb';
          row.appendChild(toggle);
          row.appendChild(nameEl);
          const childrenUl = document.createElement('ul');
          childrenUl.style.listStyle = 'none';
          childrenUl.style.margin = '0';
          childrenUl.style.paddingLeft = '1rem';
          childrenUl.style.display = 'none';
          row.addEventListener('click', () => {
            const open = childrenUl.style.display !== 'none';
            childrenUl.style.display = open ? 'none' : 'block';
            toggle.textContent = open ? '▸' : '▾';
          });
          li.appendChild(row);
          li.appendChild(childrenUl);
          return { li, childrenUl };
        }

        function createFileLi(path) {
          const li = document.createElement('li');
          li.style.padding = '0.25rem 0.5rem';
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.gap = '0.4rem';
          // Count on far left
          const countBadge = document.createElement('span');
          countBadge.className = 'badge';
          countBadge.style.order = '0';
          const c = counts[path] || 0;
          countBadge.textContent = String(c);

          const nameEl = document.createElement('span');
          nameEl.textContent = path.split('/').pop();
          nameEl.style.color = '#e5e7eb';
          nameEl.style.cursor = 'pointer';

          // Clicking filename loads just that file into flat list for selection
          nameEl.addEventListener('click', (e) => {
            e.stopPropagation();
            currentFilePath = path;
            filteredLogs = logs.filter((en) => en && en.__sourcePath === path);
            filterQuery = '';
            logFilter.value = '';
            renderList();
            if (filteredLogs.length) selectLog(0);
          });

          row.appendChild(countBadge);
          row.appendChild(nameEl);
          li.appendChild(row);
          return li;
        }

        function walk(node, ul, prefix) {
          const keys = Object.keys(node).sort((a, b) => a.localeCompare(b));
          keys.forEach((k) => {
            const v = node[k];
            const full = prefix ? prefix + '/' + k : k;
            if (v && v.__file) {
              ul.appendChild(createFileLi(full));
            } else {
              const { li, childrenUl } = createFolderLi(k);
              ul.appendChild(li);
              walk(v, childrenUl, full);
            }
          });
        }

        walk(root, treeRoot, '');
      }

      // File filter (left sidebar): filters visible nodes by name
      let fileFilterTimer = null;
      fileFilter.addEventListener('input', (e) => {
        const q = String(e.target.value || '').trim().toLowerCase();
        if (fileFilterTimer) clearTimeout(fileFilterTimer);
        fileFilterTimer = setTimeout(() => {
          Array.from(treeRoot.querySelectorAll('li')).forEach((li) => {
            const txt = (li.textContent || '').toLowerCase();
            li.style.display = q ? (txt.includes(q) ? '' : 'none') : '';
          });
        }, 120);
      });
    })();
  </script>
</body>
</html>