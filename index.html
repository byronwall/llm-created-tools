<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Screenshot Color Sampler</title>
    <style>
      :root {
        --gap: 1rem;
      }
      body {
        font-family: sans-serif;
        margin: var(--gap);
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--gap);
      }
      .canvas-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.25rem;
        position: relative;
      }
      canvas {
        border: 1px solid #ccc;
        width: 100%;
        max-width: 100%;
        cursor: crosshair;
        box-sizing: border-box;
      }
      .controls {
        grid-column: span 2;
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }
      .table-wrapper {
        grid-column: span 2;
        overflow-x: auto;
      }
      table {
        border-collapse: collapse;
        width: 100%;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 0.5rem;
        text-align: center;
      }
      #dropZone {
        grid-column: span 2;
        border: 2px dashed #999;
        padding: 1rem;
        text-align: center;
        margin-bottom: 1rem;
        user-select: none;
      }
      .active-label {
        font-size: 0.85rem;
      }
      .canvas-container {
        position: relative;
        display: inline-block;
      }
      .svg-overlay {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 10;
      }
      .draggable-dot {
        cursor: move;
        pointer-events: all;
      }
      .dot-label {
        font-family: Arial, sans-serif;
        font-size: 12px;
        font-weight: bold;
        fill: white;
        text-anchor: middle;
        dominant-baseline: central;
        pointer-events: none;
      }
      .remove-btn {
        background: #ff4444;
        color: white;
        border: none;
        padding: 2px 6px;
        cursor: pointer;
        font-size: 12px;
        border-radius: 3px;
      }
      .remove-btn:hover {
        background: #cc0000;
      }
      .color-swatch {
        width: 30px;
        height: 30px;
        display: inline-block;
        border: 1px solid #ddd;
        border-radius: 3px;
      }
      .preview-canvas {
        width: 50px;
        height: 50px;
        border: 1px solid #ddd;
        image-rendering: pixelated;
      }
      .coord-input {
        width: 50px;
        padding: 2px;
        text-align: center;
        border: 1px solid #ddd;
        border-radius: 3px;
      }
      .sync-checkbox {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <div id="dropZone">
      Drop <strong>or paste</strong> two images here (1st = BEFORE, 2nd =
      AFTER). Active target is highlighted.
    </div>
    <input type="file" id="file1" accept="image/*" style="display: none" />
    <input type="file" id="file2" accept="image/*" style="display: none" />

    <div class="canvas-wrapper">
      <label class="active-label"
        ><input type="checkbox" id="cb1" /> Active</label
      >
      <div class="canvas-container">
        <canvas id="canvas1"></canvas>
        <svg class="svg-overlay" id="svg1"></svg>
      </div>
      <button onclick="document.getElementById('file1').click();">
        Choose Image 1
      </button>
    </div>
    <div class="canvas-wrapper">
      <label class="active-label"
        ><input type="checkbox" id="cb2" /> Active</label
      >
      <div class="canvas-container">
        <canvas id="canvas2"></canvas>
        <svg class="svg-overlay" id="svg2"></svg>
      </div>
      <button onclick="document.getElementById('file2').click();">
        Choose Image 2
      </button>
    </div>

    <div class="controls">
      <button id="clearBtn">Clear Points</button>
      <button id="randomBtn">Sample 10 Random Points</button>
    </div>
    <div class="table-wrapper">
      <table id="results">
        <thead>
          <tr>
            <th>#</th>
            <th>Swatch Before</th>
            <th>Hex Before</th>
            <th>Swatch After</th>
            <th>Hex After</th>
            <th>HSL Before</th>
            <th>HSL After</th>
            <th>Preview Before</th>
            <th>Preview After</th>
            <th>X Before</th>
            <th>Y Before</th>
            <th>X After</th>
            <th>Y After</th>
            <th>Sync</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <script>
      const canvases = [
        document.getElementById("canvas1"),
        document.getElementById("canvas2"),
      ];
      const svgs = [
        document.getElementById("svg1"),
        document.getElementById("svg2"),
      ];
      const files = [
        document.getElementById("file1"),
        document.getElementById("file2"),
      ];
      const checkboxes = [
        document.getElementById("cb1"),
        document.getElementById("cb2"),
      ];
      let images = [null, null];
      let activeIndex = 0; // 0 => before, 1 => after
      let points = [];
      let pointIdCounter = 1;
      let draggedPoint = null;
      
      checkboxes[0].checked = true;
      checkboxes.forEach((cb, i) =>
        cb.addEventListener("change", () => {
          if (cb.checked) {
            activeIndex = i;
            checkboxes[1 - i].checked = false;
          }
        })
      );
      function loadFile(file, index) {
        if (!file) return;
        const img = new Image();
        img.onload = () => {
          drawImageToCanvas(img, canvases[index]);
          images[index] = img;
        };
        img.src = URL.createObjectURL(file);
      }
      files.forEach(
        (input, idx) =>
          (input.onchange = (e) => loadFile(e.target.files[0], idx))
      );
      function drawImageToCanvas(img, canvas) {
        const ratio = img.width / img.height;
        const maxWidth = 800;
        const width = Math.min(img.width, maxWidth);
        const height = width / ratio;
        canvas.width = width;
        canvas.height = height;
        canvas.getContext("2d").drawImage(img, 0, 0, width, height);
        
        // Update SVG overlay size
        const svgIndex = canvases.indexOf(canvas);
        if (svgIndex !== -1) {
          const svg = svgs[svgIndex];
          svg.setAttribute('width', width);
          svg.setAttribute('height', height);
        }
      }
      function hex(r, g, b) {
        return (
          "#" +
          [r, g, b]
            .map((v) => v.toString(16).padStart(2, "0"))
            .join("")
            .toUpperCase()
        );
      }
      function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b),
          min = Math.min(r, g, b);
        let h,
          s,
          l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return `hsl(${Math.round(h * 360)}, ${Math.round(
          s * 100
        )}%, ${Math.round(l * 100)}%)`;
      }
      const tbody = document.querySelector("#results tbody");
      
      function addRow(pointId, hex1, hex2, hsl1, hsl2, x1, y1, x2, y2) {
        const tr = document.createElement("tr");
        tr.setAttribute('data-point-id', pointId);
        
        // Create color swatches
        const swatch1 = `<div class="color-swatch" style="background-color: ${hex1}"></div>`;
        const swatch2 = `<div class="color-swatch" style="background-color: ${hex2}"></div>`;
        
        // Create preview canvases
        const preview1 = createPreviewCanvas(0, x1, y1);
        const preview2 = createPreviewCanvas(1, x2, y2);
        
        tr.innerHTML = `
          <td>${pointId}</td>
          <td>${swatch1}</td>
          <td>${hex1}</td>
          <td>${swatch2}</td>
          <td>${hex2}</td>
          <td>${hsl1}</td>
          <td>${hsl2}</td>
          <td>${preview1}</td>
          <td>${preview2}</td>
          <td><input type="number" class="coord-input" value="${Math.round(x1)}" onchange="updatePointCoord(${pointId}, 'x1', this.value)"></td>
          <td><input type="number" class="coord-input" value="${Math.round(y1)}" onchange="updatePointCoord(${pointId}, 'y1', this.value)"></td>
          <td><input type="number" class="coord-input" value="${Math.round(x2)}" onchange="updatePointCoord(${pointId}, 'x2', this.value)"></td>
          <td><input type="number" class="coord-input" value="${Math.round(y2)}" onchange="updatePointCoord(${pointId}, 'y2', this.value)"></td>
          <td><input type="checkbox" class="sync-checkbox" onchange="togglePointSync(${pointId}, this.checked)"></td>
          <td><button class="remove-btn" onclick="removePoint(${pointId})">Remove</button></td>
        `;
        tbody.appendChild(tr);
      }
      
      function removePoint(pointId) {
        // Remove from points array
        points = points.filter(p => p.id !== pointId);
        
        // Remove from table
        const row = document.querySelector(`tr[data-point-id="${pointId}"]`);
        if (row) row.remove();
        
        // Remove from SVG overlays
        svgs.forEach(svg => {
          const dotGroup = svg.querySelector(`g[data-point-id="${pointId}"]`);
          if (dotGroup) dotGroup.remove();
        });
      }
      function getColorAt(canvas, x, y) {
        return canvas.getContext("2d").getImageData(x, y, 1, 1).data;
      }
      function createSVGDot(svg, x, y, pointId) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('data-point-id', pointId);
        g.setAttribute('class', 'draggable-dot');
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', '8');
        circle.setAttribute('fill', 'none');
        circle.setAttribute('stroke', 'red');
        circle.setAttribute('stroke-width', '3');
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('class', 'dot-label');
        text.textContent = pointId;
        
        g.appendChild(circle);
        g.appendChild(text);
        svg.appendChild(g);
        
        // Add drag functionality
        addDragBehavior(g, circle, text, pointId);
        
        return g;
      }
      
      function addDragBehavior(group, circle, text, pointId) {
        let isDragging = false;
        let startX, startY;
        
        group.addEventListener('mousedown', (e) => {
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          draggedPoint = pointId;
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging || draggedPoint !== pointId) return;
          
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          const currentX = parseFloat(circle.getAttribute('cx'));
          const currentY = parseFloat(circle.getAttribute('cy'));
          
          const newX = currentX + deltaX;
          const newY = currentY + deltaY;
          
          // Update position
          circle.setAttribute('cx', newX);
          circle.setAttribute('cy', newY);
          text.setAttribute('x', newX);
          text.setAttribute('y', newY);
          
          // Update point in array
          const point = points.find(p => p.id === pointId);
          if (point) {
            const svgIndex = svgs.indexOf(group.parentNode);
            if (svgIndex === 0) {
              point.x1 = newX;
              point.y1 = newY;
              
              // If synced, update the other canvas too
              if (point.synced) {
                point.x2 = newX;
                point.y2 = newY;
                const otherGroup = svgs[1].querySelector(`g[data-point-id="${pointId}"]`);
                if (otherGroup) {
                  const otherCircle = otherGroup.querySelector('circle');
                  const otherText = otherGroup.querySelector('text');
                  otherCircle.setAttribute('cx', newX);
                  otherCircle.setAttribute('cy', newY);
                  otherText.setAttribute('x', newX);
                  otherText.setAttribute('y', newY);
                }
              }
            } else {
              point.x2 = newX;
              point.y2 = newY;
              
              // If synced, update the other canvas too
              if (point.synced) {
                point.x1 = newX;
                point.y1 = newY;
                const otherGroup = svgs[0].querySelector(`g[data-point-id="${pointId}"]`);
                if (otherGroup) {
                  const otherCircle = otherGroup.querySelector('circle');
                  const otherText = otherGroup.querySelector('text');
                  otherCircle.setAttribute('cx', newX);
                  otherCircle.setAttribute('cy', newY);
                  otherText.setAttribute('x', newX);
                  otherText.setAttribute('y', newY);
                }
              }
            }
            updatePointColors(point);
          }
          
          startX = e.clientX;
          startY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
          isDragging = false;
          draggedPoint = null;
        });
      }
      
      function updatePointColors(point) {
        const c1 = getColorAt(canvases[0], point.x1, point.y1);
        const c2 = getColorAt(canvases[1], point.x2, point.y2);
        
        const row = document.querySelector(`tr[data-point-id="${point.id}"]`);
        if (row) {
          const cells = row.getElementsByTagName('td');
          const hex1 = hex(c1[0], c1[1], c1[2]);
          const hex2 = hex(c2[0], c2[1], c2[2]);
          
          // Update swatches
          cells[1].innerHTML = `<div class="color-swatch" style="background-color: ${hex1}"></div>`;
          cells[2].textContent = hex1;
          cells[3].innerHTML = `<div class="color-swatch" style="background-color: ${hex2}"></div>`;
          cells[4].textContent = hex2;
          cells[5].textContent = rgbToHsl(c1[0], c1[1], c1[2]);
          cells[6].textContent = rgbToHsl(c2[0], c2[1], c2[2]);
          
          // Update previews
          cells[7].innerHTML = createPreviewCanvas(0, point.x1, point.y1);
          cells[8].innerHTML = createPreviewCanvas(1, point.x2, point.y2);
          
          // Update coordinates
          cells[9].querySelector('input').value = Math.round(point.x1);
          cells[10].querySelector('input').value = Math.round(point.y1);
          cells[11].querySelector('input').value = Math.round(point.x2);
          cells[12].querySelector('input').value = Math.round(point.y2);
        }
      }
      
      function clickHandler(e) {
        if (!images[0] || !images[1]) return;
        const rect = this.getBoundingClientRect();
        const x = Math.round(e.clientX - rect.left);
        const y = Math.round(e.clientY - rect.top);
        
        // Create new point
        const pointId = pointIdCounter++;
        const point = {
          id: pointId,
          x1: x,
          y1: y,
          x2: x,
          y2: y,
          synced: false
        };
        points.push(point);
        
        // Add dots to both SVG overlays
        svgs.forEach(svg => {
          createSVGDot(svg, x, y, pointId);
        });
        
        // Get colors and add to table
        const c1 = getColorAt(canvases[0], x, y);
        const c2 = getColorAt(canvases[1], x, y);
        addRow(
          pointId,
          hex(c1[0], c1[1], c1[2]),
          hex(c2[0], c2[1], c2[2]),
          rgbToHsl(c1[0], c1[1], c1[2]),
          rgbToHsl(c2[0], c2[1], c2[2]),
          x, y, x, y
        );
      }
      canvases.forEach((c) => c.addEventListener("click", clickHandler));
      document.getElementById("clearBtn").onclick = () => {
        tbody.innerHTML = "";
        points = [];
        pointIdCounter = 1;
        svgs.forEach(svg => {
          svg.innerHTML = '';
        });
        images.forEach((img, i) => {
          if (img) drawImageToCanvas(img, canvases[i]);
        });
      };
      // Handle drag & drop
      const dropZone = document.getElementById("dropZone");
      ["dragenter", "dragover"].forEach((evt) =>
        dropZone.addEventListener(evt, (e) => {
          e.preventDefault();
          dropZone.style.borderColor = "#333";
        })
      );
      ["dragleave", "drop"].forEach((evt) =>
        dropZone.addEventListener(evt, (e) => {
          e.preventDefault();
          dropZone.style.borderColor = "#999";
        })
      );
      dropZone.addEventListener("drop", (e) => {
        const filesArr = [...e.dataTransfer.files].filter((f) =>
          f.type.startsWith("image/")
        );
        filesArr.forEach((f) => {
          loadFile(f, activeIndex);
          toggleActive();
        });
      });
      // Handle paste
      function handlePaste(e) {
        const items = [...e.clipboardData.items];
        for (const item of items) {
          if (item.type.startsWith("image/")) {
            const file = item.getAsFile();
            loadFile(file, activeIndex);
            toggleActive();
            e.preventDefault();
            break;
          }
        }
      }
      function toggleActive() {
        activeIndex = 1 - activeIndex;
        checkboxes[activeIndex].checked = true;
        checkboxes[1 - activeIndex].checked = false;
      }
      
      function createPreviewCanvas(canvasIndex, x, y) {
        if (!images[canvasIndex]) return '';
        
        const canvas = document.createElement('canvas');
        canvas.width = 10;
        canvas.height = 10;
        canvas.className = 'preview-canvas';
        
        const ctx = canvas.getContext('2d');
        const sourceCanvas = canvases[canvasIndex];
        
        // Extract 10x10 pixel area centered on the point
        const startX = Math.max(0, Math.floor(x - 5));
        const startY = Math.max(0, Math.floor(y - 5));
        const endX = Math.min(sourceCanvas.width, startX + 10);
        const endY = Math.min(sourceCanvas.height, startY + 10);
        
        const imageData = sourceCanvas.getContext('2d').getImageData(startX, startY, endX - startX, endY - startY);
        ctx.putImageData(imageData, 0, 0);
        
        return canvas.outerHTML;
      }
      
      function updatePointCoord(pointId, coord, value) {
        const point = points.find(p => p.id === pointId);
        if (!point) return;
        
        const numValue = parseFloat(value);
        if (isNaN(numValue)) return;
        
        point[coord] = numValue;
        
        // Update SVG dots
        const isFirstCanvas = coord === 'x1' || coord === 'y1';
        const svgIndex = isFirstCanvas ? 0 : 1;
        const svg = svgs[svgIndex];
        const dotGroup = svg.querySelector(`g[data-point-id="${pointId}"]`);
        
        if (dotGroup) {
          const circle = dotGroup.querySelector('circle');
          const text = dotGroup.querySelector('text');
          
          if (coord.endsWith('1')) {
            circle.setAttribute('cx', point.x1);
            circle.setAttribute('cy', point.y1);
            text.setAttribute('x', point.x1);
            text.setAttribute('y', point.y1);
          } else {
            circle.setAttribute('cx', point.x2);
            circle.setAttribute('cy', point.y2);
            text.setAttribute('x', point.x2);
            text.setAttribute('y', point.y2);
          }
        }
        
        // Update colors and previews
        updatePointColors(point);
      }
      
      function togglePointSync(pointId, synced) {
        const point = points.find(p => p.id === pointId);
        if (!point) return;
        
        point.synced = synced;
      }
      
      function sampleRandomPoints() {
        if (!images[0] || !images[1]) {
          alert('Please load both images first');
          return;
        }
        
        const width = canvases[0].width;
        const height = canvases[0].height;
        
        for (let i = 0; i < 10; i++) {
          const x = Math.floor(Math.random() * width);
          const y = Math.floor(Math.random() * height);
          
          // Create new point
          const pointId = pointIdCounter++;
          const point = {
            id: pointId,
            x1: x,
            y1: y,
            x2: x,
            y2: y,
            synced: false
          };
          points.push(point);
          
          // Add dots to both SVG overlays
          svgs.forEach(svg => {
            createSVGDot(svg, x, y, pointId);
          });
          
          // Get colors and add to table
          const c1 = getColorAt(canvases[0], x, y);
          const c2 = getColorAt(canvases[1], x, y);
          addRow(
            pointId,
            hex(c1[0], c1[1], c1[2]),
            hex(c2[0], c2[1], c2[2]),
            rgbToHsl(c1[0], c1[1], c1[2]),
            rgbToHsl(c2[0], c2[1], c2[2]),
            x, y, x, y
          );
        }
      }
      
      document.addEventListener("paste", handlePaste);
      
      // Add event listener for random sampling button
      document.getElementById('randomBtn').addEventListener('click', sampleRandomPoints);
    </script>
  </body>
</html>
