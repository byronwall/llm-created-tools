<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Screenshot Color Sampler</title>
    <style>
      :root {
        --gap: 1rem;
      }
      body {
        font-family: sans-serif;
        margin: var(--gap);
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--gap);
      }
      .canvas-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.25rem;
        position: relative;
      }
      canvas {
        border: 1px solid #ccc;
        width: 100%;
        max-width: 100%;
        cursor: crosshair;
        box-sizing: border-box;
      }
      .controls {
        grid-column: span 2;
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }
      .table-wrapper {
        grid-column: span 2;
        overflow-x: auto;
      }
      table {
        border-collapse: collapse;
        width: 100%;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 0.5rem;
        text-align: center;
      }
      #dropZone {
        grid-column: span 2;
        border: 2px dashed #999;
        padding: 1rem;
        text-align: center;
        margin-bottom: 1rem;
        user-select: none;
      }
      .active-label {
        font-size: 0.85rem;
      }
      .canvas-container {
        position: relative;
        display: inline-block;
      }
      .svg-overlay {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 10;
      }
      .draggable-dot {
        cursor: move;
        pointer-events: all;
      }
      .dot-label {
        font-family: Arial, sans-serif;
        font-size: 12px;
        font-weight: bold;
        fill: white;
        text-anchor: middle;
        dominant-baseline: central;
        pointer-events: none;
      }
      .remove-btn {
        background: #ff4444;
        color: white;
        border: none;
        padding: 2px 6px;
        cursor: pointer;
        font-size: 12px;
        border-radius: 3px;
      }
      .remove-btn:hover {
        background: #cc0000;
      }
    </style>
  </head>
  <body>
    <div id="dropZone">
      Drop <strong>or paste</strong> two images here (1st = BEFORE, 2nd =
      AFTER). Active target is highlighted.
    </div>
    <input type="file" id="file1" accept="image/*" style="display: none" />
    <input type="file" id="file2" accept="image/*" style="display: none" />

    <div class="canvas-wrapper">
      <label class="active-label"
        ><input type="checkbox" id="cb1" /> Active</label
      >
      <div class="canvas-container">
        <canvas id="canvas1"></canvas>
        <svg class="svg-overlay" id="svg1"></svg>
      </div>
      <button onclick="document.getElementById('file1').click();">
        Choose Image 1
      </button>
    </div>
    <div class="canvas-wrapper">
      <label class="active-label"
        ><input type="checkbox" id="cb2" /> Active</label
      >
      <div class="canvas-container">
        <canvas id="canvas2"></canvas>
        <svg class="svg-overlay" id="svg2"></svg>
      </div>
      <button onclick="document.getElementById('file2').click();">
        Choose Image 2
      </button>
    </div>

    <div class="controls">
      <button id="clearBtn">Clear Points</button>
    </div>
    <div class="table-wrapper">
      <table id="results">
        <thead>
          <tr>
            <th>#</th>
            <th>Hex Before</th>
            <th>Hex After</th>
            <th>HSL Before</th>
            <th>HSL After</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <script>
      const canvases = [
        document.getElementById("canvas1"),
        document.getElementById("canvas2"),
      ];
      const svgs = [
        document.getElementById("svg1"),
        document.getElementById("svg2"),
      ];
      const files = [
        document.getElementById("file1"),
        document.getElementById("file2"),
      ];
      const checkboxes = [
        document.getElementById("cb1"),
        document.getElementById("cb2"),
      ];
      let images = [null, null];
      let activeIndex = 0; // 0 => before, 1 => after
      let points = [];
      let pointIdCounter = 1;
      let draggedPoint = null;
      
      checkboxes[0].checked = true;
      checkboxes.forEach((cb, i) =>
        cb.addEventListener("change", () => {
          if (cb.checked) {
            activeIndex = i;
            checkboxes[1 - i].checked = false;
          }
        })
      );
      function loadFile(file, index) {
        if (!file) return;
        const img = new Image();
        img.onload = () => {
          drawImageToCanvas(img, canvases[index]);
          images[index] = img;
        };
        img.src = URL.createObjectURL(file);
      }
      files.forEach(
        (input, idx) =>
          (input.onchange = (e) => loadFile(e.target.files[0], idx))
      );
      function drawImageToCanvas(img, canvas) {
        const ratio = img.width / img.height;
        const maxWidth = 800;
        const width = Math.min(img.width, maxWidth);
        const height = width / ratio;
        canvas.width = width;
        canvas.height = height;
        canvas.getContext("2d").drawImage(img, 0, 0, width, height);
        
        // Update SVG overlay size
        const svgIndex = canvases.indexOf(canvas);
        if (svgIndex !== -1) {
          const svg = svgs[svgIndex];
          svg.setAttribute('width', width);
          svg.setAttribute('height', height);
        }
      }
      function hex(r, g, b) {
        return (
          "#" +
          [r, g, b]
            .map((v) => v.toString(16).padStart(2, "0"))
            .join("")
            .toUpperCase()
        );
      }
      function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b),
          min = Math.min(r, g, b);
        let h,
          s,
          l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return `hsl(${Math.round(h * 360)}, ${Math.round(
          s * 100
        )}%, ${Math.round(l * 100)}%)`;
      }
      const tbody = document.querySelector("#results tbody");
      
      function addRow(pointId, hex1, hex2, hsl1, hsl2) {
        const tr = document.createElement("tr");
        tr.setAttribute('data-point-id', pointId);
        tr.innerHTML = `<td>${pointId}</td><td>${hex1}</td><td>${hex2}</td><td>${hsl1}</td><td>${hsl2}</td><td><button class="remove-btn" onclick="removePoint(${pointId})">Remove</button></td>`;
        tbody.appendChild(tr);
      }
      
      function removePoint(pointId) {
        // Remove from points array
        points = points.filter(p => p.id !== pointId);
        
        // Remove from table
        const row = document.querySelector(`tr[data-point-id="${pointId}"]`);
        if (row) row.remove();
        
        // Remove from SVG overlays
        svgs.forEach(svg => {
          const dotGroup = svg.querySelector(`g[data-point-id="${pointId}"]`);
          if (dotGroup) dotGroup.remove();
        });
      }
      function getColorAt(canvas, x, y) {
        return canvas.getContext("2d").getImageData(x, y, 1, 1).data;
      }
      function createSVGDot(svg, x, y, pointId) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('data-point-id', pointId);
        g.setAttribute('class', 'draggable-dot');
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', '8');
        circle.setAttribute('fill', 'red');
        circle.setAttribute('stroke', 'white');
        circle.setAttribute('stroke-width', '2');
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('class', 'dot-label');
        text.textContent = pointId;
        
        g.appendChild(circle);
        g.appendChild(text);
        svg.appendChild(g);
        
        // Add drag functionality
        addDragBehavior(g, circle, text, pointId);
        
        return g;
      }
      
      function addDragBehavior(group, circle, text, pointId) {
        let isDragging = false;
        let startX, startY;
        
        group.addEventListener('mousedown', (e) => {
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          draggedPoint = pointId;
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging || draggedPoint !== pointId) return;
          
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          const currentX = parseFloat(circle.getAttribute('cx'));
          const currentY = parseFloat(circle.getAttribute('cy'));
          
          const newX = currentX + deltaX;
          const newY = currentY + deltaY;
          
          // Update position
          circle.setAttribute('cx', newX);
          circle.setAttribute('cy', newY);
          text.setAttribute('x', newX);
          text.setAttribute('y', newY);
          
          // Update point in array
          const point = points.find(p => p.id === pointId);
          if (point) {
            const svgIndex = svgs.indexOf(group.parentNode);
            if (svgIndex === 0) {
              point.x1 = newX;
              point.y1 = newY;
            } else {
              point.x2 = newX;
              point.y2 = newY;
            }
            updatePointColors(point);
          }
          
          startX = e.clientX;
          startY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
          isDragging = false;
          draggedPoint = null;
        });
      }
      
      function updatePointColors(point) {
        const c1 = getColorAt(canvases[0], point.x1, point.y1);
        const c2 = getColorAt(canvases[1], point.x2, point.y2);
        
        const row = document.querySelector(`tr[data-point-id="${point.id}"]`);
        if (row) {
          const cells = row.getElementsByTagName('td');
          cells[1].textContent = hex(c1[0], c1[1], c1[2]);
          cells[2].textContent = hex(c2[0], c2[1], c2[2]);
          cells[3].textContent = rgbToHsl(c1[0], c1[1], c1[2]);
          cells[4].textContent = rgbToHsl(c2[0], c2[1], c2[2]);
        }
      }
      
      function clickHandler(e) {
        if (!images[0] || !images[1]) return;
        const rect = this.getBoundingClientRect();
        const x = Math.round(e.clientX - rect.left);
        const y = Math.round(e.clientY - rect.top);
        
        // Create new point
        const pointId = pointIdCounter++;
        const point = {
          id: pointId,
          x1: x,
          y1: y,
          x2: x,
          y2: y
        };
        points.push(point);
        
        // Add dots to both SVG overlays
        svgs.forEach(svg => {
          createSVGDot(svg, x, y, pointId);
        });
        
        // Get colors and add to table
        const c1 = getColorAt(canvases[0], x, y);
        const c2 = getColorAt(canvases[1], x, y);
        addRow(
          pointId,
          hex(c1[0], c1[1], c1[2]),
          hex(c2[0], c2[1], c2[2]),
          rgbToHsl(c1[0], c1[1], c1[2]),
          rgbToHsl(c2[0], c2[1], c2[2])
        );
      }
      canvases.forEach((c) => c.addEventListener("click", clickHandler));
      document.getElementById("clearBtn").onclick = () => {
        tbody.innerHTML = "";
        points = [];
        pointIdCounter = 1;
        svgs.forEach(svg => {
          svg.innerHTML = '';
        });
        images.forEach((img, i) => {
          if (img) drawImageToCanvas(img, canvases[i]);
        });
      };
      // Handle drag & drop
      const dropZone = document.getElementById("dropZone");
      ["dragenter", "dragover"].forEach((evt) =>
        dropZone.addEventListener(evt, (e) => {
          e.preventDefault();
          dropZone.style.borderColor = "#333";
        })
      );
      ["dragleave", "drop"].forEach((evt) =>
        dropZone.addEventListener(evt, (e) => {
          e.preventDefault();
          dropZone.style.borderColor = "#999";
        })
      );
      dropZone.addEventListener("drop", (e) => {
        const filesArr = [...e.dataTransfer.files].filter((f) =>
          f.type.startsWith("image/")
        );
        filesArr.forEach((f) => {
          loadFile(f, activeIndex);
          toggleActive();
        });
      });
      // Handle paste
      function handlePaste(e) {
        const items = [...e.clipboardData.items];
        for (const item of items) {
          if (item.type.startsWith("image/")) {
            const file = item.getAsFile();
            loadFile(file, activeIndex);
            toggleActive();
            e.preventDefault();
            break;
          }
        }
      }
      function toggleActive() {
        activeIndex = 1 - activeIndex;
        checkboxes[activeIndex].checked = true;
        checkboxes[1 - activeIndex].checked = false;
      }
      document.addEventListener("paste", handlePaste);
    </script>
  </body>
</html>
