<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>textPath: startOffset vs text-anchor — Small Multiples</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #0b1020;
        --ink: #e5e7eb;
        --muted: #94a3b8;
        --muted-2: #64748b;
        --path: #f59e0b;
        --start: #60a5fa;
        --mid: #34d399;
        --end: #f472b6;
      }
      html,
      body {
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Arial;
      }
      header {
        padding: 14px 18px;
        border-bottom: 1px solid #111827;
      }
      header h1 {
        margin: 0 0 4px;
        font-size: 16px;
      }
      header p {
        margin: 0;
        opacity: 0.85;
        font-size: 13px;
      }
      .section {
        padding: 18px;
      }
      .section h2 {
        margin: 0 0 10px;
        font-size: 14px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: #cbd5e1;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 14px;
      }
      .cell {
        background: #0e152c;
        border: 1px solid #111827;
        border-radius: 10px;
        box-shadow: 0 1px 0 rgba(255, 255, 255, 0.03) inset,
          0 6px 18px rgba(0, 0, 0, 0.25);
        overflow: hidden;
      }
      .cell header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 10px;
        border: 0;
        border-bottom: 1px solid #111827;
        background: #0c1326;
      }
      .title {
        font-size: 12px;
        color: #cbd5e1;
      }
      .code {
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        color: #a3e635;
        font-size: 11px;
        opacity: 0.9;
      }
      svg {
        display: block;
        width: 100%;
        height: auto;
        background: #0a1021;
      }
      .winding {
        fill: none;
        stroke: var(--path);
        stroke-width: 3;
      }
      .anchor-dot {
        fill: var(--muted-2);
        stroke: var(--bg);
        stroke-width: 2;
      }
      .label {
        font-size: 11px;
        fill: #cbd5e1;
      }
      .start {
        fill: var(--start);
      }
      .middle {
        fill: var(--mid);
      }
      .end {
        fill: var(--end);
      }
      .guide {
        stroke: var(--muted);
        stroke-width: 1;
        stroke-dasharray: 3 5;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>SVG <code>textPath</code> — startOffset vs text-anchor</h1>
      <p>
        Each small multiple reuses the same winding path, marks the anchor
        point, and labels the setting. No <code>dy</code> is used.
      </p>
    </header>

    <!-- Sections -->
    <section class="section" id="offset-only">
      <h2>StartOffset only (text-anchor=start)</h2>
      <div class="grid"></div>
    </section>

    <section class="section" id="anchor-only">
      <h2>Text-anchor only (startOffset=50%)</h2>
      <div class="grid"></div>
    </section>

    <section class="section" id="combos">
      <h2>Combinations (startOffset × text-anchor)</h2>
      <div class="grid"></div>
    </section>

    <script>
      // ---- Data sets ------------------------------------------------------------
      const OFFSET_ONLY = ["0%", "25%", "50%", "75%", "100%"].map((o) => ({
        startOffset: o,
        anchor: "start",
      }));
      const ANCHOR_ONLY = ["start", "middle", "end"].map((a) => ({
        startOffset: "50%",
        anchor: a,
      }));
      const COMBOS = [];
      ["0%", "25%", "50%", "75%"].forEach((o) => {
        ["start", "middle", "end"].forEach((a) =>
          COMBOS.push({ startOffset: o, anchor: a })
        );
      });

      // ---- Utilities ------------------------------------------------------------
      let uid = 0;
      const nextId = (prefix) => `${prefix}-${++uid}`;

      function windingPathD() {
        // Gentle S-curves across 280×120 area; stays away from edges to avoid crowding.
        return `
      M 20 80 C 60 40 110 110 158 71 S 230 40 228 59 S 200 110 156 118 S 80 60 27 110
    `;
      }

      function makeCell(container, { startOffset, anchor }) {
        const cell = document.createElement("div");
        cell.className = "cell";

        // header
        const head = document.createElement("header");
        const t = document.createElement("div");
        t.className = "title";
        t.textContent = "textPath";
        const code = document.createElement("div");
        code.className = "code";
        code.textContent = `startOffset=${startOffset}, text-anchor=${anchor}`;
        head.appendChild(t);
        head.appendChild(code);
        cell.appendChild(head);

        // svg
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("viewBox", "0 0 300 160");

        // path
        const pathId = nextId("p");
        const p = document.createElementNS(svgNS, "path");
        p.setAttribute("id", pathId);
        p.setAttribute("class", "winding");
        p.setAttribute("d", windingPathD());
        svg.appendChild(p);

        // anchor dot + label (computed by length)
        const dot = document.createElementNS(svgNS, "circle");
        dot.setAttribute("class", "anchor-dot");
        dot.setAttribute("r", "4");
        dot.setAttribute("cx", "-10");
        dot.setAttribute("cy", "-10");
        svg.appendChild(dot);

        const lab = document.createElementNS(svgNS, "text");
        lab.setAttribute("class", "label");
        lab.textContent = `${startOffset}`;
        svg.appendChild(lab);

        // textPath text (short to keep things legible)
        const text = document.createElementNS(svgNS, "text");
        // Place the <text> baseline via translate (no 'dy' anywhere)
        text.setAttribute("transform", "translate(0,0)");

        const textPath = document.createElementNS(svgNS, "textPath");
        textPath.setAttribute("href", `#${pathId}`);
        textPath.setAttribute("startOffset", startOffset);
        textPath.setAttribute("text-anchor", anchor);
        textPath.setAttribute(
          "class",
          anchor === "start" ? "start" : anchor === "middle" ? "middle" : "end"
        );
        // Create two tspans: <tspan>Anchor</tspan><tspan>Demo</tspan>
        const tspan1 = document.createElementNS(svgNS, "tspan");
        tspan1.textContent = "Anchor";
        const tspan2 = document.createElementNS(svgNS, "tspan");
        tspan2.textContent = "Demo";
        textPath.appendChild(tspan1);
        textPath.appendChild(tspan2);
        text.appendChild(textPath);
        svg.appendChild(text);

        // after first paint, compute anchor point from path length & startOffset
        requestAnimationFrame(() => {
          const len = p.getTotalLength();
          const pct = parseStartOffset(startOffset);
          const pt = p.getPointAtLength(len * pct);

          dot.setAttribute("cx", pt.x);
          dot.setAttribute("cy", pt.y);
          lab.setAttribute("x", pt.x + 8);
          lab.setAttribute("y", Math.max(12, pt.y - 8)); // keep label inside cell

          console.log("Cell", {
            startOffset,
            anchor,
            pathLength: Math.round(len),
            anchorPoint: { x: Math.round(pt.x), y: Math.round(pt.y) },
          });
        });

        container.appendChild(cell);
        cell.appendChild(svg);
      }

      function parseStartOffset(so) {
        if (typeof so === "string" && so.endsWith("%"))
          return parseFloat(so) / 100;
        const n = Number(so);
        if (Number.isFinite(n)) return n; // treat as user-space length fraction (rare)
        return 0; // default
      }

      // ---- Build all sections ---------------------------------------------------
      const offsetOnlyGrid = document.querySelector("#offset-only .grid");
      OFFSET_ONLY.forEach((cfg) => makeCell(offsetOnlyGrid, cfg));

      const anchorOnlyGrid = document.querySelector("#anchor-only .grid");
      ANCHOR_ONLY.forEach((cfg) => makeCell(anchorOnlyGrid, cfg));

      const combosGrid = document.querySelector("#combos .grid");
      COMBOS.forEach((cfg) => makeCell(combosGrid, cfg));

      // Recompute anchors on resize (viewBox scales)
      window.addEventListener("resize", () => {
        document.querySelectorAll(".cell").forEach((cell) => {
          const p = cell.querySelector("path.winding");
          const dot = cell.querySelector("circle.anchor-dot");
          const lab = cell.querySelector("text.label");
          const tp = cell.querySelector("textPath");
          if (!p || !dot || !tp || !lab) return;

          const len = p.getTotalLength();
          const pct = parseStartOffset(tp.getAttribute("startOffset") || "0%");
          const pt = p.getPointAtLength(len * pct);
          dot.setAttribute("cx", pt.x);
          dot.setAttribute("cy", pt.y);
          lab.setAttribute("x", pt.x + 8);
          lab.setAttribute("y", Math.max(12, pt.y - 8));
        });
        console.log("Resized: anchor points recomputed.");
      });
    </script>
  </body>
</html>
