<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Grid ‚Ä¢ Shapes ‚Ä¢ Gradients ‚Ä¢ Noise ‚Äî SVG Generator</title>
    <style>
      :root {
        --bg: #0b0b12;
        --panel: #12121c;
        --ink: #e8e8f1;
        --muted: #9aa0b0;
        --accent: #68b5ff;
        --accent-2: #ff9a55;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        color: var(--ink);
        background: var(--bg);
        font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji";
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 8px;
      }
      header,
      footer {
        padding: 10px 14px;
        background: linear-gradient(180deg, #0f0f19, #0b0b12);
        border-bottom: 1px solid #1c1d2b;
      }
      header h1 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }
      .tabs {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }
      .tab-btn {
        appearance: none;
        border: 1px solid #2b2d3a;
        background: #0f1018;
        color: var(--ink);
        padding: 6px 10px;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 600;
        font-size: 12px;
      }
      .tab-btn.active {
        background: linear-gradient(180deg, #1a2638, #121a28);
        border-color: #2b3d59;
        color: #dfe9ff;
      }
      main {
        display: grid;
        grid-template-columns: 340px 1fr;
        gap: 12px;
        padding: 12px;
      }
      @media (max-width: 1000px) {
        main {
          grid-template-columns: 1fr;
        }
      }
      .panel {
        background: var(--panel);
        border: 1px solid #1f2130;
        border-radius: 14px;
        padding: 14px;
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.02) inset,
          0 10px 30px rgba(0, 0, 0, 0.25);
      }
      .controls {
        display: grid;
        gap: 10px;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .grid-3 {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }
      .grid > label,
      .grid-3 > label {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      label span {
        color: var(--muted);
        font-size: 12px;
      }
      input[type="number"],
      input[type="text"],
      select,
      textarea {
        background: #0f1018;
        color: var(--ink);
        border: 1px solid #2a2c3b;
        border-radius: 10px;
        padding: 8px 10px;
        outline: none;
      }
      input[type="range"] {
        width: 100%;
      }
      textarea {
        min-height: 110px;
        resize: vertical;
      }
      .btn {
        appearance: none;
        border: 1px solid #2b2d3a;
        background: #131422;
        color: var(--ink);
        padding: 10px 12px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }
      .btn:hover {
        border-color: #3a3d50;
      }
      .btn.primary {
        background: linear-gradient(180deg, #1a2638, #121a28);
        border-color: #2b3d59;
        color: #dfe9ff;
      }
      .btn.ghost {
        background: #0f1018;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .pill {
        padding: 4px 8px;
        border: 1px solid #2a2c3b;
        border-radius: 999px;
        cursor: pointer;
        user-select: none;
      }
      .pill.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(104, 181, 255, 0.25) inset;
      }
      #stage-wrap {
        display: grid;
        align-items: start; /* align content to top */
        justify-items: center;
      }
      #stage {
        width: 100%;
        max-width: 1200px;
        height: auto;
        aspect-ratio: 16/9;
        background: #0c0d16;
        border-radius: 16px;
        border: 1px solid #1a1c27;
      }
      #gridGallery {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }
      .thumb {
        background: #0c0d16;
        border-radius: 12px;
        border: 1px solid #1a1c27;
        padding: 6px;
        display: grid;
        gap: 6px;
        transition: transform 0.12s ease;
        cursor: pointer;
      }
      .thumb:hover {
        transform: translateY(-2px);
      }
      .thumb svg {
        width: 100%;
        height: auto;
        aspect-ratio: 16/9;
        border-radius: 10px;
        display: block;
      }
      .thumb .meta {
        font-size: 12px;
        color: var(--muted);
      }
      .help {
        color: var(--muted);
        font-size: 12px;
      }
      details {
        margin-top: 8px;
      }
      .chiprow {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }
      .chip {
        border: 1px dashed #33364a;
        border-radius: 10px;
        padding: 6px 8px;
        font-size: 12px;
      }
      code.inline {
        background: #0e1020;
        padding: 2px 6px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Grid + Shapes + Gradients + Noise (SVG) ‚Äî Generator & Explorer</h1>
      <div class="tabs">
        <button id="tabDetail" class="tab-btn active">Detail view</button>
        <button id="tabGrid" class="tab-btn">Grid view</button>
      </div>
    </header>

    <main>
      <section class="panel controls">
        <div class="grid">
          <label
            ><span>Seed</span><input id="seed" type="text" value="oranges-1"
          /></label>
          <label
            ><span>Auto-refresh</span>
            <select id="autorefresh">
              <option value="change" selected>On change</option>
              <option value="manual">Manual</option>
            </select>
          </label>
          <label
            ><span>Width (px)</span
            ><input id="w" type="number" value="1200" min="200" step="10"
          /></label>
          <label
            ><span>Height (px)</span
            ><input id="h" type="number" value="675" min="200" step="10"
          /></label>
        </div>

        <div class="grid">
          <label
            ><span>Cols</span
            ><input id="cols" type="number" value="12" min="1" max="64"
          /></label>
          <label
            ><span>Rows</span
            ><input id="rows" type="number" value="8" min="1" max="64"
          /></label>
          <label
            ><span>Cell Pad</span
            ><input id="pad" type="number" value="6" min="0" max="40"
          /></label>
          <label
            ><span>Corner Radius</span
            ><input id="r" type="number" value="22" min="0" max="120"
          /></label>
        </div>

        <div class="grid">
          <label
            ><span>Palette</span>
            <select id="palette"></select>
          </label>
          <label
            ><span>Palette Strategy</span>
            <select id="paletteStrategy">
              <option value="fixed" selected>Fixed palette</option>
              <option value="analogous">Analogous (HSL)</option>
              <option value="triad">Triad (HSL)</option>
              <option value="mono">Monochrome (HSL)</option>
            </select>
          </label>
        </div>

        <div class="grid">
          <label
            ><span>Base Gradient</span>
            <select id="gradKind">
              <option>linear</option>
              <option>radial</option>
              <option selected>sweepish</option>
            </select>
          </label>
          <label
            ><span>Gradient Stops</span
            ><input id="stops" type="number" value="6" min="2" max="12"
          /></label>
        </div>

        <div class="grid">
          <label
            ><span>Noise (0‚Äì1)</span
            ><input
              id="noise"
              type="range"
              min="0"
              max="1"
              step="0.01"
              value="0.25"
          /></label>
          <label
            ><span>Noise Freq</span
            ><input
              id="freq"
              type="range"
              min="0.001"
              max="2"
              step="0.001"
              value="0.85"
          /></label>
        </div>

        <div class="grid">
          <label
            ><span>Noise Kind</span>
            <select id="noiseKind">
              <option value="fractal-fine" selected>
                Fractal Fine (grain)
              </option>
              <option value="fractal-soft">Fractal Soft (mist)</option>
              <option value="paper-fiber">Paper Fiber</option>
              <option value="stipple">Blue-ish Stipple</option>
              <option value="film-dust">Film Dust</option>
            </select>
          </label>
        </div>

        <div class="grid">
          <label
            ><span>Pattern Overlay</span>
            <select id="pattern">
              <option value="none">None</option>
              <option value="arcs" selected>Concentric Arcs</option>
              <option value="quarters">Quarter-Circles Grid</option>
              <option value="circles">Circles Grid</option>
              <option value="bands">Curved Bands</option>
            </select>
          </label>
          <label
            ><span>Pattern Opacity</span
            ><input
              id="patOp"
              type="range"
              min="0"
              max="1"
              step="0.01"
              value="0.65"
          /></label>
        </div>

        <div class="grid-3">
          <label
            ><span>Grid Overlay</span>
            <select id="gridOverlay">
              <option value="none">None</option>
              <option value="soft" selected>Soft squares</option>
              <option value="hard">Hard squares</option>
              <option value="checker">Checker</option>
            </select>
          </label>
          <label
            ><span>Grid Opacity</span
            ><input
              id="gridOpacity"
              type="range"
              min="0"
              max="1"
              step="0.01"
              value="0.25"
          /></label>
          <label
            ><span>Hotspot</span>
            <select id="hotspot">
              <option>none</option>
              <option selected>corner</option>
              <option>center</option>
              <option>edge</option>
            </select>
          </label>
        </div>

        <div class="row">
          <button id="btnRandomize" class="btn">üé≤ Randomize</button>
          <button id="btnShuffle" class="btn ghost">üé® Shuffle Palette</button>
          <button id="btnRender" class="btn primary">‚ö° Render</button>
        </div>

        <div class="row">
          <button id="btnCopySVG" class="btn">üìã Copy SVG</button>
          <button id="btnDownloadSVG" class="btn">‚¨áÔ∏è Download SVG</button>
          <button id="btnCopyConfig" class="btn ghost">üìã Copy Config</button>
          <button id="btnShare" class="btn ghost">üîó Share URL</button>
        </div>

        <label
          ><span>Current Config (live)</span>
          <textarea id="configOut" spellcheck="false"></textarea>
        </label>

        <div class="help">
          Tip: everything is deterministic per <em>Seed</em>. Share links encode
          config in the URL hash.
        </div>
      </section>

      <section id="stage-wrap" class="panel">
        <svg
          id="stage"
          xmlns="http://www.w3.org/2000/svg"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          role="img"
          aria-label="Generated artwork"
        ></svg>
      </section>

      <section id="grid-wrap" class="panel" style="display: none">
        <div
          class="row"
          style="
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
          "
        >
          <div class="chiprow">
            <span class="chip">3√ó3 random gallery</span>
            <span class="chip">Click a tile to focus</span>
          </div>
          <button id="btnRerollGrid" class="btn primary">
            üé≤ Generate 3√ó3
          </button>
        </div>
        <div id="gridGallery"></div>
      </section>
    </main>

    <footer class="help">
      Built with pure SVG: gradients, clipPaths, turbulence noise, and a few
      pattern renderers.
    </footer>

    <script>
      /* =========================
   Utilities & PRNG (seeded)
   ========================= */
      function cLog(msg, data) {
        console.log("[SVGGen]", msg, data || "");
      }

      function hashStr(str) {
        // xfnv1a 32-bit
        let h = 0x811c9dc5;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 0x01000193);
        }
        return h >>> 0;
      }
      function mulberry32(a) {
        return function () {
          let t = (a += 0x6d2b79f5);
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }
      // sample helpers
      const randInt = (rng, min, max) =>
        Math.floor(rng() * (max - min + 1)) + min;
      const choice = (rng, arr) => arr[Math.floor(rng() * arr.length)];
      const lerp = (a, b, t) => a + (b - a) * t;

      // HSL/Hex helpers
      function hsl(h, s, l) {
        return `hsl(${h % 360} ${s}% ${l}%)`;
      }
      function hexToHSL(hex) {
        hex = hex.replace("#", "");
        if (hex.length === 3)
          hex = hex
            .split("")
            .map((x) => x + x)
            .join("");
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;
        const max = Math.max(r, g, b),
          min = Math.min(r, g, b);
        let h,
          s,
          l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h *= 60;
        }
        return { h, s: Math.round(s * 100), l: Math.round(l * 100) };
      }

      /* =========================
   Palettes
   ========================= */
      const PALETTES = {
        "Warm Sunset": ["#FFD29D", "#FFB36D", "#FF8A3D", "#FF5A36", "#E7352A"],
        "Cool Blue": ["#C7E8FF", "#8DD2FF", "#56B6FF", "#2E8CFF", "#1B4DFF"],
        "Royal Purple": ["#D9C8FF", "#B79CFF", "#8A6FFF", "#6047D9", "#3B2E8C"],
        "Citrus Pop": ["#FFF4C1", "#FFE16B", "#FFC300", "#FF8C00", "#FF3B3B"],
        "Teal Ocean": ["#CEFFF7", "#8BF4E6", "#4DD9D0", "#22A7B3", "#0C6C7C"],
        "Rose Sky": ["#FFE3F0", "#FFC0DA", "#FF95C0", "#F060A6", "#C53F8D"],
      };

      // Populate palette picker
      const paletteSel = document.querySelector("#palette");
      for (const k of Object.keys(PALETTES)) {
        const opt = document.createElement("option");
        opt.value = k;
        opt.textContent = k;
        if (k === "Warm Sunset") opt.selected = true;
        paletteSel.appendChild(opt);
      }

      /* =========================
   Config management
   ========================= */
      function currentConfig() {
        return {
          seed: document.querySelector("#seed").value.trim(),
          size: { w: +w.value, h: +h.value },
          grid: {
            cols: +cols.value,
            rows: +rows.value,
            pad: +pad.value,
            radius: +r.value,
          },
          paletteKind: document.querySelector("#palette").value,
          paletteStrategy: document.querySelector("#paletteStrategy").value,
          gradient: { kind: gradKind.value, stops: +stops.value },
          noise: { opacity: +noise.value, freq: +freq.value },
          noiseKind:
            document.querySelector("#noiseKind")?.value || "fractal-fine",
          overlay: {
            grid: gridOverlay.value,
            gridOpacity: +gridOpacity.value,
            hotspot: hotspot.value,
          },
          pattern: { kind: pattern.value, opacity: +patOp.value },
        };
      }
      function setConfig(cfg) {
        seed.value = cfg.seed;
        w.value = cfg.size.w;
        h.value = cfg.size.h;
        cols.value = cfg.grid.cols;
        rows.value = cfg.grid.rows;
        pad.value = cfg.grid.pad;
        r.value = cfg.grid.radius;
        palette.value = cfg.paletteKind;
        paletteStrategy.value = cfg.paletteStrategy;
        gradKind.value = cfg.gradient.kind;
        stops.value = cfg.gradient.stops;
        noise.value = cfg.noise.opacity;
        freq.value = cfg.noise.freq;
        if (cfg.noiseKind) {
          const nk = document.querySelector("#noiseKind");
          if (nk) nk.value = cfg.noiseKind;
        }
        gridOverlay.value = cfg.overlay.grid;
        gridOpacity.value = cfg.overlay.gridOpacity;
        hotspot.value = cfg.overlay.hotspot;
        pattern.value = cfg.pattern.kind;
        patOp.value = cfg.pattern.opacity;
        updateConfigOut();
      }
      function updateConfigOut() {
        configOut.value = JSON.stringify(currentConfig(), null, 2);
      }

      /* =========================
   Palette strategies
   ========================= */
      function derivePalette(rng, base, strategy) {
        if (strategy === "fixed") return base.slice();
        const hslBase = hexToHSL(choice(rng, base));
        const out = [];
        const n = 5;
        if (strategy === "analogous") {
          const step = 18 + rng() * 8;
          for (let i = -2; i <= 2; i++) {
            out.push(
              hsl(
                hslBase.h + i * step,
                55 + randInt(rng, 20, 35),
                45 + randInt(rng, -10, 15)
              )
            );
          }
        } else if (strategy === "triad") {
          const roots = [0, 120, 240];
          for (const r of roots) {
            const h = hslBase.h + r + randInt(rng, -10, 10);
            out.push(
              hsl(h, 65 + randInt(rng, 10, 20), 50 + randInt(rng, -10, 10))
            );
          }
          // extend
          out.push(hsl(hslBase.h + 60, 70, 55));
          out.push(hsl(hslBase.h + 180, 70, 45));
        } else if (strategy === "mono") {
          const baseL = hslBase.l;
          for (let i = 0; i < n; i++) {
            const l = Math.max(
              10,
              Math.min(90, baseL + (i - 2) * 10 + randInt(rng, -4, 4))
            );
            out.push(
              hsl(
                hslBase.h,
                Math.max(20, hslBase.s - 10 + randInt(rng, -5, 5)),
                l
              )
            );
          }
        }
        return out;
      }

      /* =========================
   SVG building
   ========================= */
      function el(ns, name, attrs = {}, children = []) {
        const e = document.createElementNS(ns, name);
        for (const [k, v] of Object.entries(attrs)) {
          if (v == null) continue;
          e.setAttribute(k, String(v));
        }
        for (const c of children) e.appendChild(c);
        return e;
      }
      const SVGNS = "http://www.w3.org/2000/svg";
      function clearNode(node) {
        while (node.firstChild) node.removeChild(node.firstChild);
      }

      /* =========================
   Gradient builders
   ========================= */
      function buildGradient(defs, id, kind, colors, rng, nStops) {
        if (kind === "linear") {
          const g = el(SVGNS, "linearGradient", {
            id,
            x1: "0%",
            y1: "0%",
            x2: "100%",
            y2: "0%",
          });
          g.setAttribute(
            "gradientTransform",
            `rotate(${Math.floor(rng() * 360)})`
          );
          addStops(g, colors, rng);
          defs.appendChild(g);
          return `url(#${id})`;
        }
        if (kind === "radial") {
          const g = el(SVGNS, "radialGradient", {
            id,
            cx: `${randInt(rng, 20, 80)}%`,
            cy: `${randInt(rng, 20, 80)}%`,
            r: `${randInt(rng, 60, 90)}%`,
          });
          addStops(g, colors, rng);
          defs.appendChild(g);
          return `url(#${id})`;
        }
        // sweepish (simulate conic with many linear stops in a radial gradient)
        const g = el(SVGNS, "radialGradient", {
          id,
          cx: `50%`,
          cy: `50%`,
          r: `80%`,
        });
        addStops(g, colors, rng, true);
        defs.appendChild(g);
        return `url(#${id})`;

        function addStops(grad, cols, rng, jitter = false) {
          const n = nStops || cols.length;
          for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const col =
              cols[Math.floor(t * (cols.length - 1))] || choice(rng, cols);
            const off = jitter
              ? Math.min(1, Math.max(0, t + (rng() - 0.5) * 0.06))
              : t;
            grad.appendChild(
              el(SVGNS, "stop", { offset: off, "stop-color": col })
            );
          }
        }
      }

      /* =========================
   Noise filter
   ========================= */

      // --- New: Multi-model SVG noise layer ---
      function addNoiseLayer({ defs, svg, cfg, rng, ids }) {
        const id = ids?.noise || "noiseF";
        const kind = cfg.noiseKind || "fractal-fine";
        const { w, h } = cfg.size;

        // Build filter or pattern depending on kind
        if (kind === "stipple") {
          // deterministic point pattern (tiny dots)
          const patId = ids?.stipple || "stipplePat";
          const pat = el(SVGNS, "pattern", {
            id: patId,
            patternUnits: "userSpaceOnUse",
            width: 3,
            height: 3,
          });
          // sprinkle ~6 tiny dots in a 3x3 tile (seeded)
          const r2 = mulberry32(hashStr(cfg.seed) ^ 0xa5a5);
          for (let i = 0; i < 6; i++) {
            const cx = (r2() * 3).toFixed(3);
            const cy = (r2() * 3).toFixed(3);
            const rr = (0.25 + r2() * 0.35).toFixed(3);
            pat.appendChild(
              el(SVGNS, "circle", {
                cx,
                cy,
                r: rr,
                fill: "black",
                opacity: 0.45,
              })
            );
          }
          defs.appendChild(pat);
          svg.appendChild(
            el(SVGNS, "rect", {
              x: 0,
              y: 0,
              width: w,
              height: h,
              fill: `url(#${patId})`,
              opacity: cfg.noise.opacity,
            })
          );
          return;
        }

        // Filter-based grains
        const f = el(SVGNS, "filter", {
          id,
          x: "-10%",
          y: "-10%",
          width: "120%",
          height: "120%",
          filterUnits: "objectBoundingBox",
        });
        let baseFreq = cfg.noise.freq ?? 0.85; // use cfg
        let oct = 1;
        let turbType = "fractalNoise";

        if (kind === "fractal-fine") {
          turbType = "fractalNoise";
          // very small, crispy grain (higher baseFrequency is smaller grain)
          baseFreq = Math.max(0.4, baseFreq);
          oct = 1;
        } else if (kind === "fractal-soft") {
          turbType = "fractalNoise";
          baseFreq = Math.min(0.2, Math.max(0.02, baseFreq * 0.15));
          oct = 3;
        } else if (kind === "paper-fiber") {
          turbType = "turbulence";
          baseFreq = 0.02 + rng() * 0.02; // directional fibers
          oct = 2;
        } else if (kind === "film-dust") {
          turbType = "fractalNoise";
          baseFreq = Math.max(0.6, baseFreq);
          oct = 1;
        }

        // turbulence
        const turb = el(SVGNS, "feTurbulence", {
          type: turbType,
          baseFrequency: `${baseFreq} ${baseFreq}`,
          numOctaves: oct,
          seed: randInt(rng, 1, 9999),
          stitchTiles: "stitch",
        });
        f.appendChild(turb);

        if (kind === "film-dust") {
          // threshold the noise into sparse specks
          f.appendChild(
            el(SVGNS, "feColorMatrix", {
              type: "matrix",
              values: `
              0 0 0 0 0
              0 0 0 0 0
              0 0 0 0 0
              0 0 0 40 -20
            `
                .trim()
                .replace(/\s+/g, " "),
            })
          );
        } else {
          // desaturate -> contrast -> soften a touch
          f.appendChild(
            el(SVGNS, "feColorMatrix", { type: "saturate", values: "0" })
          );
          f.appendChild(
            el(SVGNS, "feComponentTransfer", {}, [
              el(SVGNS, "feFuncA", {
                type: "gamma",
                amplitude: "1",
                exponent: "0.35",
                offset: "0",
              }),
            ])
          );
          f.appendChild(el(SVGNS, "feGaussianBlur", { stdDeviation: "0.15" }));
        }

        // blend atop: k2 acts like simple alpha (arithmetic comp)
        f.appendChild(
          el(SVGNS, "feComposite", {
            operator: "arithmetic",
            k1: "0",
            k2: "1",
            k3: "0",
            k4: "0",
          })
        );
        defs.appendChild(f);

        svg.appendChild(
          el(SVGNS, "rect", {
            x: 0,
            y: 0,
            width: w,
            height: h,
            filter: `url(#${id})`,
            opacity: cfg.noise.opacity,
          })
        );
      }

      /* =========================
   Renderers
   ========================= */
      const renderers = {
        base({ svg, defs, cfg, rng, ids }) {
          const { w, h } = cfg.size;
          const pal = derivePalette(
            rng,
            PALETTES[cfg.paletteKind],
            cfg.paletteStrategy
          );
          const gradFill = buildGradient(
            defs,
            ids.gradBase,
            cfg.gradient.kind,
            pal,
            rng,
            cfg.gradient.stops
          );

          svg.appendChild(
            el(SVGNS, "rect", {
              x: 0,
              y: 0,
              width: w,
              height: h,
              fill: gradFill,
              rx: cfg.grid.radius,
              ry: cfg.grid.radius,
            })
          );

          // optional hotspot‚Ä¶
          if (cfg.overlay.hotspot !== "none") {
            const gId = ids.hot;
            const hotG = el(SVGNS, "radialGradient", { id: gId });
            const c = choice(rng, pal);
            const where = (() => {
              switch (cfg.overlay.hotspot) {
                case "center":
                  return { cx: "50%", cy: "50%" };
                case "edge":
                  return {
                    cx: `${randInt(rng, 10, 90)}%`,
                    cy: rng() < 0.5 ? "5%" : "95%",
                  };
                default:
                  return { cx: "85%", cy: "85%" };
              }
            })();
            hotG.setAttribute("cx", where.cx);
            hotG.setAttribute("cy", where.cy);
            hotG.setAttribute("r", "65%");
            hotG.appendChild(
              el(SVGNS, "stop", {
                offset: "0%",
                "stop-color": c,
                "stop-opacity": 0.8,
              })
            );
            hotG.appendChild(
              el(SVGNS, "stop", {
                offset: "100%",
                "stop-color": c,
                "stop-opacity": 0,
              })
            );
            defs.appendChild(hotG);
            svg.appendChild(
              el(SVGNS, "rect", {
                x: 0,
                y: 0,
                width: w,
                height: h,
                fill: `url(#${gId})`,
              })
            );
          }

          return { palette: pal };
        },

        gridOverlay({ svg, cfg, rng, ids }) {
          const { w, h } = cfg.size;
          const { rows, cols, pad } = cfg.grid;
          const cellW = w / cols,
            cellH = h / rows;

          const g = el(SVGNS, "g", {
            "clip-path": `url(#${ids.clip})`,
            opacity: cfg.overlay.gridOpacity,
          });
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const x = c * cellW + pad / 2,
                y = r * cellH + pad / 2;
              const ww = cellW - pad,
                hh = cellH - pad;
              let fill = "rgba(255,255,255,0.1)";
              if (cfg.overlay.grid === "soft") {
                fill = `rgba(255,255,255,${
                  0.08 + ((r + c) / (rows + cols)) * 0.06
                })`;
              } else if (cfg.overlay.grid === "hard") {
                fill = `rgba(0,0,0,${0.18 + rng() * 0.15})`;
              } else if (cfg.overlay.grid === "checker") {
                const on = (r + c) % 2 === 0;
                fill = on ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.14)";
              } else continue;
              g.appendChild(
                el(SVGNS, "rect", {
                  x,
                  y,
                  width: ww,
                  height: hh,
                  rx: 8,
                  ry: 8,
                  fill,
                })
              );
            }
          }
          svg.appendChild(g);
        },

        pattern_arcs({ svg, cfg, rng, palette, ids }) {
          const { w, h } = cfg.size;
          const g = el(SVGNS, "g", {
            opacity: cfg.pattern.opacity,
            "clip-path": `url(#${ids.clip})`,
          });
          const cx = lerp(w * 0.2, w * 0.85, rng());
          const cy = lerp(h * 0.2, h * 0.85, rng());
          const maxR = Math.hypot(Math.max(cx, w - cx), Math.max(cy, h - cy));
          const bands = randInt(rng, 6, 14);
          for (let i = 0; i < bands; i++) {
            const t = i / (bands - 1);
            const r = lerp(40, maxR, t * t);
            const path = arcPath(cx, cy, r, -90, 270); // big circle arc
            const col = palette[i % palette.length];
            const sw = Math.max(6, Math.round((maxR / bands) * 0.5));
            g.appendChild(
              el(SVGNS, "path", {
                d: path,
                fill: "none",
                stroke: col,
                "stroke-width": sw,
                "stroke-linecap": "round",
                "stroke-opacity": 0.9,
              })
            );
          }
          svg.appendChild(g);

          function arcPath(cx, cy, r, a0, a1) {
            const p0 = polar(cx, cy, r, a0),
              p1 = polar(cx, cy, r, a1);
            const large = Math.abs(a1 - a0) % 360 > 180 ? 1 : 0;
            const sweep = a1 > a0 ? 1 : 0;
            return `M ${p0.x} ${p0.y} A ${r} ${r} 0 ${large} ${sweep} ${p1.x} ${p1.y}`;
          }
          function polar(cx, cy, r, deg) {
            const t = (deg * Math.PI) / 180;
            return { x: cx + Math.cos(t) * r, y: cy + Math.sin(t) * r };
          }
        },

        pattern_quarters({ svg, cfg, rng, palette, ids }) {
          const { w, h } = cfg.size;
          const { rows, cols, pad } = cfg.grid;
          const cellW = w / cols,
            cellH = h / rows;
          const g = el(SVGNS, "g", {
            opacity: cfg.pattern.opacity,
            "clip-path": `url(#${ids.clip})`,
          });
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const x = c * cellW + pad / 2,
                y = r * cellH + pad / 2;
              const ww = cellW - pad,
                hh = cellH - pad;
              const rad = Math.min(ww, hh);
              const corner = randInt(rng, 0, 3);
              const d = quarterPath(x, y, ww, hh, corner, rad);
              const col = palette[(r + c) % palette.length];
              g.appendChild(
                el(SVGNS, "path", { d, fill: col, "fill-opacity": 0.9 })
              );
            }
          }
          svg.appendChild(g);

          function quarterPath(x, y, w, h, corner, rad) {
            const rx = x + (corner % 2 ? w : 0);
            const ry = y + (corner >= 2 ? h : 0);
            const sx = x + (corner % 2 ? w : 0);
            const sy = y + (corner >= 2 ? h : 0);
            const ex = x + (corner % 2 ? 0 : w);
            const ey = y + (corner >= 2 ? 0 : h);
            return `M ${sx} ${sy} A ${rad} ${rad} 0 0 ${
              corner % 2 ? 0 : 1
            } ${ex} ${ey} L ${rx} ${ry} Z`;
          }
        },

        pattern_circles({ svg, cfg, rng, palette, ids }) {
          const { w, h } = cfg.size;
          const { rows, cols, pad } = cfg.grid;
          const cellW = w / cols,
            cellH = h / rows;
          const g = el(SVGNS, "g", {
            opacity: cfg.pattern.opacity,
            "clip-path": `url(#${ids.clip})`,
          });
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const x = c * cellW + pad / 2,
                y = r * cellH + pad / 2;
              const cx = x + cellW / 2 - pad / 2 + (rng() - 0.5) * cellW * 0.2;
              const cy = y + cellH / 2 - pad / 2 + (rng() - 0.5) * cellH * 0.2;
              const rad = Math.min(cellW, cellH) * (0.15 + rng() * 0.45);
              const fill = palette[(r * 7 + c * 5) % palette.length];
              g.appendChild(
                el(SVGNS, "circle", {
                  cx,
                  cy,
                  r: rad,
                  fill,
                  "fill-opacity": 0.9,
                })
              );
            }
          }
          svg.appendChild(g);
        },

        pattern_bands({ svg, cfg, rng, palette, ids }) {
          const { w, h } = cfg.size;
          const g = el(SVGNS, "g", {
            opacity: cfg.pattern.opacity,
            "clip-path": `url(#${ids.clip})`,
          });
          const bands = randInt(rng, 5, 12);
          const sw = Math.max(14, Math.floor((w / bands) * 0.75));
          const cx = w * (0.3 + rng() * 0.6);
          const r0 = Math.max(w, h) * (0.5 + rng() * 0.4);
          for (let i = 0; i < bands; i++) {
            const r = r0 + i * sw * 0.9;
            const col = palette[(i * 2) % palette.length];
            const d = `M ${-100} ${h + 100} A ${r} ${r} 0 0 1 ${w + 100} ${
              h + 100
            }`;
            g.appendChild(
              el(SVGNS, "path", {
                d,
                fill: "none",
                stroke: col,
                "stroke-width": sw,
                transform: `translate(${cx - w / 2},0)`,
              })
            );
          }
          svg.appendChild(g);
        },
      };

      /* =========================
   Main render function
   ========================= */
      function renderTo(svg, cfg) {
        cLog("renderTo() cfg", cfg);
        svg.setAttribute("viewBox", `0 0 ${cfg.size.w} ${cfg.size.h}`);
        svg.setAttribute("width", cfg.size.w);
        svg.setAttribute("height", cfg.size.h);
        clearNode(svg);

        const defs = el(SVGNS, "defs");
        svg.appendChild(defs);

        // unique ids per render to avoid collisions
        const idPrefix =
          "i" +
          (Math.random().toString(36).slice(2, 8) +
            hashStr(cfg.seed).toString(36));
        const ids = {
          clip: `${idPrefix}-clip`,
          gradBase: `${idPrefix}-grad`,
          hot: `${idPrefix}-hot`,
          noise: `${idPrefix}-noise`,
          stipple: `${idPrefix}-stip`,
        };

        // master rounded clip
        const clip = el(SVGNS, "clipPath", { id: ids.clip });
        clip.appendChild(
          el(SVGNS, "rect", {
            x: 0,
            y: 0,
            width: cfg.size.w,
            height: cfg.size.h,
            rx: cfg.grid.radius,
            ry: cfg.grid.radius,
          })
        );
        defs.appendChild(clip);

        // everything goes inside this group
        const scene = el(SVGNS, "g", { "clip-path": `url(#${ids.clip})` });
        svg.appendChild(scene);

        // determinism
        const rng = mulberry32(hashStr(cfg.seed));

        // base gradient on rounded rect (shows the radius immediately)
        const palInfo = renderers.base({ svg: scene, defs, cfg, rng, ids });
        renderers.gridOverlay({ svg: scene, cfg, rng, ids });

        const kind = cfg.pattern.kind;
        if (kind !== "none") {
          const fn = {
            arcs: "pattern_arcs",
            quarters: "pattern_quarters",
            circles: "pattern_circles",
            bands: "pattern_bands",
          }[kind];
          renderers[fn]({
            svg: scene,
            cfg,
            rng,
            palette: palInfo.palette,
            ids,
          });
        }

        if (cfg.noise.opacity > 0) {
          addNoiseLayer({ defs, svg: scene, cfg, rng, ids });
        }

        // Caller decides whether to update UI output
      }

      function render(cfg) {
        const svg = document.querySelector("#stage");
        renderTo(svg, cfg);
        updateConfigOut();
      }

      /* =========================
   Export / Share helpers
   ========================= */
      function svgToText() {
        const svg = document.querySelector("#stage");
        const pre = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        const s = new XMLSerializer().serializeToString(svg);
        return pre + s;
      }
      async function copyText(text) {
        await navigator.clipboard.writeText(text);
      }
      function download(name, text) {
        const blob = new Blob([text], { type: "image/svg+xml" });
        const a = Object.assign(document.createElement("a"), {
          download: name,
          href: URL.createObjectURL(blob),
        });
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(a.href), 1000);
      }
      function encodeShare(cfg) {
        return btoa(unescape(encodeURIComponent(JSON.stringify(cfg))));
      }
      function decodeShare(hash) {
        try {
          return JSON.parse(decodeURIComponent(escape(atob(hash))));
        } catch (e) {
          return null;
        }
      }

      /* =========================
   Wire up UI
   ========================= */
      const formEls = Array.from(
        document.querySelectorAll(
          "#seed,#w,#h,#cols,#rows,#pad,#r,#palette,#paletteStrategy,#gradKind,#stops,#noise,#freq,#noiseKind,#gridOverlay,#gridOpacity,#hotspot,#pattern,#patOp,#autorefresh"
        )
      );

      function maybeRender() {
        if (autorefresh.value === "change") render(currentConfig());
      }
      formEls.forEach((el) => el.addEventListener("input", maybeRender));
      formEls.forEach((el) => el.addEventListener("change", maybeRender));

      btnRandomize.addEventListener("click", (e) => {
        e.preventDefault();

        seed.value = "seed-" + Math.random().toString(36).slice(2, 8);

        // grid
        cols.value = randInt(Math.random, 3, 32);
        rows.value = randInt(Math.random, 3, 24);
        pad.value = randInt(Math.random, 0, 28);
        r.value = randInt(Math.random, 0, 80);

        // palette
        palette.value = choice(Math.random, Object.keys(PALETTES));
        paletteStrategy.value = choice(Math.random, [
          "fixed",
          "analogous",
          "triad",
          "mono",
        ]);

        // gradient
        gradKind.value = choice(Math.random, ["linear", "radial", "sweepish"]);
        stops.value = randInt(Math.random, 3, 10);

        // noise
        const kinds = [
          "fractal-fine",
          "fractal-soft",
          "paper-fiber",
          "stipple",
          "film-dust",
        ];
        noiseKind.value = choice(Math.random, kinds);
        // higher freq ‚Üí smaller grain; let opacity be subtle
        freq.value = +(0.5 + Math.random() * 1.2).toFixed(3); // 0.5..1.7
        noise.value = +(0.08 + Math.random() * 0.35).toFixed(2); // 0.08..0.43

        // overlays
        gridOverlay.value = choice(Math.random, [
          "none",
          "soft",
          "hard",
          "checker",
        ]);
        gridOpacity.value = +(Math.random() * 0.45).toFixed(2); // softer by default
        hotspot.value = choice(Math.random, [
          "none",
          "corner",
          "center",
          "edge",
        ]);

        // patterns
        pattern.value = choice(Math.random, [
          "none",
          "arcs",
          "quarters",
          "circles",
          "bands",
        ]);
        patOp.value = +(Math.random() * 0.9).toFixed(2);

        maybeRender();
      });

      btnShuffle.addEventListener("click", (e) => {
        e.preventDefault();
        palette.value = choice(Math.random, Object.keys(PALETTES));
        paletteStrategy.value = choice(Math.random, [
          "fixed",
          "analogous",
          "triad",
          "mono",
        ]);
        maybeRender();
      });

      btnRender.addEventListener("click", (e) => {
        e.preventDefault();
        render(currentConfig());
      });

      btnCopySVG.addEventListener("click", async (e) => {
        e.preventDefault();
        await copyText(svgToText());
        btnCopySVG.textContent = "‚úî Copied SVG";
        setTimeout(() => (btnCopySVG.textContent = "üìã Copy SVG"), 900);
      });

      btnCopyConfig.addEventListener("click", async (e) => {
        e.preventDefault();
        await copyText(JSON.stringify(currentConfig(), null, 2));
        btnCopyConfig.textContent = "‚úî Copied Config";
        setTimeout(() => (btnCopyConfig.textContent = "üìã Copy Config"), 900);
      });

      btnDownloadSVG.addEventListener("click", (e) => {
        e.preventDefault();
        const cfg = currentConfig();
        download(`art-${cfg.seed}.svg`, svgToText());
      });

      btnShare.addEventListener("click", async (e) => {
        e.preventDefault();
        const hash = encodeShare(currentConfig());
        const url = location.origin + location.pathname + "#" + hash;
        await copyText(url);
        history.replaceState(null, "", "#" + hash);
        btnShare.textContent = "‚úî Link Copied";
        setTimeout(() => (btnShare.textContent = "üîó Share URL"), 900);
      });

      /* =========================
   Tabs + Grid view
   ========================= */
      const tabDetail = document.querySelector("#tabDetail");
      const tabGrid = document.querySelector("#tabGrid");
      const stageWrap = document.querySelector("#stage-wrap");
      const gridWrap = document.querySelector("#grid-wrap");
      const gridGallery = document.querySelector("#gridGallery");
      const btnRerollGrid = document.querySelector("#btnRerollGrid");

      function setTab(which) {
        const isGrid = which === "grid";
        tabDetail.classList.toggle("active", !isGrid);
        tabGrid.classList.toggle("active", isGrid);
        stageWrap.style.display = isGrid ? "none" : "";
        gridWrap.style.display = isGrid ? "" : "none";
      }
      tabDetail.addEventListener("click", () => setTab("detail"));
      tabGrid.addEventListener("click", () => setTab("grid"));

      // Build a randomized config without mutating the UI controls
      function randomConfig(baseSize) {
        const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
        const rint = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
        const seed = "seed-" + Math.random().toString(36).slice(2, 8);
        const paletteKind = pick(Object.keys(PALETTES));
        const paletteStrategy = pick(["fixed", "analogous", "triad", "mono"]);
        const gradKind = pick(["linear", "radial", "sweepish"]);
        const gridOverlayKind = pick(["none", "soft", "hard", "checker"]);
        const hotspotKind = pick(["none", "corner", "center", "edge"]);
        const patternKind = pick([
          "none",
          "arcs",
          "quarters",
          "circles",
          "bands",
        ]);
        const noiseKinds = [
          "fractal-fine",
          "fractal-soft",
          "paper-fiber",
          "stipple",
          "film-dust",
        ];
        const noiseKind = pick(noiseKinds);
        return {
          seed,
          size: { w: baseSize.w, h: baseSize.h },
          grid: {
            cols: rint(3, 32),
            rows: rint(3, 24),
            pad: rint(0, 28),
            radius: rint(0, 80),
          },
          paletteKind,
          paletteStrategy,
          gradient: { kind: gradKind, stops: rint(3, 10) },
          noise: {
            opacity: +(0.08 + Math.random() * 0.35).toFixed(2),
            freq: +(0.5 + Math.random() * 1.2).toFixed(3),
          },
          noiseKind,
          overlay: {
            grid: gridOverlayKind,
            gridOpacity: +(Math.random() * 0.45).toFixed(2),
            hotspot: hotspotKind,
          },
          pattern: {
            kind: patternKind,
            opacity: +(Math.random() * 0.9).toFixed(2),
          },
        };
      }

      let gridConfigs = [];
      function renderGrid() {
        // thumbnail size
        const thumbSize = { w: 480, h: 270 };
        gridConfigs = Array.from({ length: 9 }, () => randomConfig(thumbSize));
        gridGallery.innerHTML = "";
        gridConfigs.forEach((cfg, i) => {
          const wrap = document.createElement("div");
          wrap.className = "thumb";
          wrap.setAttribute("data-idx", String(i));
          const svg = document.createElementNS(SVGNS, "svg");
          svg.setAttribute("xmlns", SVGNS);
          svg.setAttribute("role", "img");
          svg.setAttribute("aria-label", "Generated thumbnail");
          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = `${cfg.paletteKind} ‚Ä¢ ${cfg.pattern.kind} ‚Ä¢ ${cfg.gradient.kind}`;
          wrap.appendChild(svg);
          wrap.appendChild(meta);
          gridGallery.appendChild(wrap);
          // Render into the thumbnail svg
          renderTo(svg, cfg);
        });
      }

      function focusFromGridIndex(idx) {
        const cfg = gridConfigs[idx];
        if (!cfg) return;
        // Use current main size for detail view
        const mainSize = { w: +w.value, h: +h.value };
        const focusCfg = { ...cfg, size: mainSize };
        setConfig(focusCfg);
        // If auto-refresh off, still render once to reflect focus
        render(currentConfig());
        setTab("detail");
      }

      gridGallery.addEventListener("click", (e) => {
        const target = e.target.closest(".thumb");
        if (!target) return;
        const idx = +target.getAttribute("data-idx");
        focusFromGridIndex(idx);
      });

      btnRerollGrid.addEventListener("click", (e) => {
        e.preventDefault();
        renderGrid();
      });

      // Load from URL hash if present
      (function boot() {
        cLog("boot()");
        if (location.hash.length > 1) {
          const cfg = decodeShare(location.hash.slice(1));
          if (cfg) {
            setConfig(cfg);
          }
        }
        render(currentConfig());
        // Prepare initial grid
        renderGrid();
      })();
    </script>
  </body>
</html>
